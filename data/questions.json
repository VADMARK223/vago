[
  {
    "topic_id": 2,
    "text": "Что напечатает код?",
    "code": "s := []int{5, 6, 7}\ns2 := append(append(s, 8), 9)\nfmt.Println(len(s), cap(s))\n",
    "explanation": "append(s, 8) уже создало новый массив, но переменная s осталась нетронутой.",
    "answers": [
      {
        "text": "3 3",
        "correct": true
      },
      {
        "text": "3 4"
      },
      {
        "text": "3 6"
      },
      {
        "text": "3 8"
      }
    ]
  },
  {
    "topic_id": 2,
    "text": "Что напечатает код?",
    "code": "s := []int{1, 2, 3}\ns2 := s[:1]       // len=1, cap=3\ns3 := append(s2, 9)\nfmt.Println(s, s3)\n",
    "explanation": "append пишет в общую память: срез s тоже меняется.",
    "answers": [
      {
        "text": "[1 2 3] [1 9]"
      },
      {
        "text": "[1 9 3] [1 9]",
        "correct": true
      },
      {
        "text": "[1 9 3] [1 9 3]"
      },
      {
        "text": "[1 2 3] [1 2 3 9]"
      }
    ]
  },
  {
    "topic_id": 2,
    "text": "Что напечатает код?",
    "code": "s := make([]int, 2, 5)\ns2 := append(s, 7)\ns2[0] = 99\nfmt.Println(s[0])\n",
    "explanation": "Общий массив, так как при append вместимости хватает (5)",
    "answers": [
      {
        "text": "99",
        "correct": true
      },
      {
        "text": "0"
      },
      {
        "text": "7"
      },
      {
        "text": "Panic"
      }
    ]
  },
  {
    "topic_id": 2,
    "text": "Что напечатает код?",
    "code": "s := []int{10, 20, 30}\ns2 := s[:2]\ns2[1] = 99\nfmt.Println(s[1])\n",
    "explanation": "Подзрезка тоже же базового массива.\nПосле подрезки в s2 [10 20], len=2, cap=3",
    "answers": [
      {
        "text": "99",
        "correct": true
      },
      {
        "text": "20"
      },
      {
        "text": "30"
      },
      {
        "text": "Panic"
      }
    ]
  },
  {
    "topic_id": 2,
    "text": "Что напечатает код?",
    "code": "s := []int{1, 2, 3}\ns2 := append(s, 4)\ns2[0] = 99\nfmt.Println(s[0])\n",
    "explanation": "В начале len=3 cap=3, под срезом лежит массив [1 2 3]\nПосле добавления 4, нет свободного места создается НОВЫЙ базовый массив с cap=6, изменения идут уже у нового массива",
    "answers": [
      {
        "text": "1",
        "correct": true
      },
      {
        "text": "99"
      },
      {
        "text": "Runtime panic"
      },
      {
        "text": "Зависит от версии Go"
      }
    ]
  },
  {
    "topic_id": 9,
    "text": "Что произойдёт при исполнении?",
    "code": "ch := make(chan int)\ngo func() {\n    ch \u003c- 10\n}()\nfmt.Println(\u003c-ch)\n",
    "explanation": "Обычная синхронная передача данных.",
    "answers": [
      {
        "text": "Deadlock"
      },
      {
        "text": "10",
        "correct": true
      },
      {
        "text": "Panic: closed channel"
      },
      {
        "text": "Неопределенное поведение"
      }
    ]
  },
  {
    "topic_id": 4,
    "text": "Что выведет код?",
    "code": "m := make(map[string]int)\nm[\"a\"] = 1\nfor k := range m {\n    delete(m, k)\n}\nfmt.Println(len(m))\n",
    "explanation": "Go допускает удаление элементов из map во время итерации.",
    "answers": [
      {
        "text": "1"
      },
      {
        "text": "0",
        "correct": true
      },
      {
        "text": "panic"
      },
      {
        "text": "Неопределенное поведение"
      }
    ]
  },
  {
    "topic_id": 11,
    "text": "Для чего нужен интерфейс error?",
    "answers": [
      {
        "text": "Для обработки исключений"
      },
      {
        "text": "Для передачи ошибок как значений",
        "correct": true
      },
      {
        "text": "Чтобы логировать ошибки автоматически"
      },
      {
        "text": "Чтобы завершать программу"
      }
    ]
  },
  {
    "topic_id": 9,
    "text": "Какая коллекция в Go является потокобезопасной по умолчанию?",
    "answers": [
      {
        "text": "Map"
      },
      {
        "text": "Slice"
      },
      {
        "text": "Channel",
        "correct": true
      },
      {
        "text": "Array"
      }
    ]
  },
  {
    "topic_id": 9,
    "text": "Какой тип передается в канал chan int?",
    "answers": [
      {
        "text": "Только указатели на int"
      },
      {
        "text": "Только значения типа int",
        "correct": true
      },
      {
        "text": "Любые числа"
      },
      {
        "text": "Любые типы"
      }
    ]
  },
  {
    "topic_id": 9,
    "text": "Что произойдёт при записи в закрытый канал?",
    "answers": [
      {
        "text": "Ничего — значение игнорируется"
      },
      {
        "text": "Запись блокируется"
      },
      {
        "text": "Происходит panic",
        "correct": true
      },
      {
        "text": "Возвращается zero-value"
      }
    ]
  },
  {
    "topic_id": 13,
    "text": "Когда происходит escape в heap?",
    "answers": [
      {
        "text": "Когда переменная слишком большая"
      },
      {
        "text": "Когда значение нужно вернуть наружу и оно \"живет\" после выхода функции",
        "correct": true
      },
      {
        "text": "Когда в функции много переменных"
      },
      {
        "text": "Когда программа вызывает panic"
      }
    ]
  },
  {
    "topic_id": 7,
    "text": "Что такое goroutine?",
    "explanation": "Горутина в Go стартует с динамическим стеком ~2 KB плюс несколько сотен байт служебных структур runtime, итого ~2–4 KB. Стек растёт и сжимается автоматически.",
    "answers": [
      {
        "text": "Отдельный процесс ОС"
      },
      {
        "text": "Лёгкая потокоподобная сущность, управляемая рантаймом Go",
        "correct": true
      },
      {
        "text": "Поток ОС"
      },
      {
        "text": "Операция ввода-вывода"
      }
    ]
  },
  {
    "topic_id": 12,
    "text": "Что делает ключевое слово defer?",
    "explanation": "Откладывает выполнение функции до момента выхода из текущей функции (в том числе при return, панике, или обычном завершении).",
    "answers": [
      {
        "text": "Выполняет функцию асинхронно"
      },
      {
        "text": "Выполняет функцию после выхода из текущей функции",
        "correct": true
      },
      {
        "text": "Отменяет выполнение функции"
      },
      {
        "text": "Экспортирует функцию"
      }
    ]
  },
  {
    "topic_id": 5,
    "text": "Какой размер у пустой структуры struct{}?",
    "answers": [
      {
        "text": "1 байт"
      },
      {
        "text": "0 байт",
        "correct": true
      },
      {
        "text": "4 байта"
      },
      {
        "text": "Зависит от архитектуры"
      }
    ]
  },
  {
    "topic_id": 2,
    "text": "Что выведет код?",
    "code": "s1 := []int{1, 2, 3}\r\ns2 := make([]int, 3)\r\ncopy(s2, s1)\r\ns2[0] = 99\r\nfmt.Println(s1[0])",
    "explanation": "copy создаёт независимые массивы (если заранее выделена память). Изменения в s2 не влияют на s1.",
    "answers": [
      {
        "text": "1",
        "correct": true
      },
      {
        "text": "99"
      },
      {
        "text": "Зависит от компилятора"
      },
      {
        "text": "panic"
      }
    ]
  },
  {
    "topic_id": 2,
    "text": "Что выведет код?",
    "code": "s1 := []int{10, 20, 30}\r\ns2 := s1[:2]\r\ncopy(s2, []int{7})\r\nfmt.Println(s1)",
    "explanation": "s2 — подрезка того же массива. copy пишет в базовый массив.",
    "answers": [
      {
        "text": "[10 20 30]"
      },
      {
        "text": "[7 20 30]",
        "correct": true
      },
      {
        "text": "[7 7 30]"
      },
      {
        "text": "[7 20]"
      }
    ]
  },
  {
    "topic_id": 2,
    "text": "Что выведет код?",
    "code": "s1 := []int{1, 2, 3, 4}\r\ns2 := make([]int, 0, 4)\r\nn := copy(s2, s1)\r\nfmt.Println(n, len(s2), cap(s2))",
    "explanation": "copy копирует минимум(len(dst), len(src)).\r\nlen(dst) = 0 ⇒ копируется 0 элементов.",
    "answers": [
      {
        "text": "4 4 4"
      },
      {
        "text": "4 0 4"
      },
      {
        "text": "0 0 4",
        "correct": true
      },
      {
        "text": "panic"
      }
    ]
  },
  {
    "topic_id": 2,
    "text": "Что выведет код?",
    "code": "s1 := []int{1, 2, 3}\r\ns2 := make([]int, 5)\r\ncopy(s2, s1)\r\ns1 = append(s1, 9)\r\nfmt.Println(s2)",
    "explanation": "s2 — независимый массив.\r\nappend(s1, 9) создаёт новый массив (cap == len) и не влияет на s2.",
    "answers": [
      {
        "text": "[1 2 3 0 0]",
        "correct": true
      },
      {
        "text": "[1 2 3 9 0]"
      },
      {
        "text": "[1 2 3 0 9]"
      },
      {
        "text": "[9 2 3 0 0]"
      }
    ]
  },
  {
    "topic_id": 2,
    "text": "Что выведет код?",
    "code": "s1 := []int{5, 6, 7, 8}\r\ns2 := s1[1:3] // [6 7]\r\ns3 := make([]int, 2)\r\ncopy(s3, s2)\r\ns2[0] = 99\r\nfmt.Println(s1, s3)",
    "explanation": "s2 ссылается на тот же массив, что и s1.\r\ns3 — независимая копия.",
    "answers": [
      {
        "text": "[5 6 7 8] [6 7]"
      },
      {
        "text": "[5 99 7 8] [6 7]",
        "correct": true
      },
      {
        "text": "[5 99 7 8] [99 7]"
      },
      {
        "text": "[5 6 7 8] [99 7]"
      }
    ]
  },
  {
    "topic_id": 12,
    "text": "Что выведет Go?",
    "code": "x := 5\r\ndefer fmt.Println(x)\r\nx = 10",
    "explanation": "Аргументы defer вычисляются в момент его объявления.",
    "answers": [
      {
        "text": "5",
        "correct": true
      },
      {
        "text": "10"
      },
      {
        "text": "компилятор выдаст ошибку"
      },
      {
        "text": "undefined behavior"
      }
    ]
  },
  {
    "topic_id": 1,
    "text": "Что произойдёт, если читать из закрытого канала?",
    "explanation": "Чтение из закрытого канала безопасно: возвращается zero-value и флаг ok=false.",
    "answers": [
      {
        "text": "Возникнет паника"
      },
      {
        "text": "Горутина заблокируется навсегда"
      },
      {
        "text": "Вернётся нулевое значение типа и ok=false",
        "correct": true
      },
      {
        "text": "Чтение будет проигнорировано"
      }
    ]
  },
  {
    "topic_id": 1,
    "text": "Какой тип используется по умолчанию для неинициализированной переменной int?",
    "explanation": "Все переменные в Go инициализируются нулевыми значениями, для int — это 0",
    "answers": [
      {
        "text": "nil"
      },
      {
        "text": "undefined"
      },
      {
        "text": "0",
        "correct": true
      },
      {
        "text": "Минимальное значение int"
      }
    ]
  },
  {
    "topic_id": 1,
    "text": "Что означает «race condition» в Go?",
    "explanation": "«Гонка данных» — состояние, когда несколько горутин одновременно обращаются к разделяемым данным без синхронизации.",
    "answers": [
      {
        "text": "Ошибка синтаксиса"
      },
      {
        "text": "Конкурентное обновление общей переменной",
        "correct": true
      },
      {
        "text": "Некорректная работа GC"
      },
      {
        "text": "Ошибка сборки"
      }
    ]
  },
  {
    "topic_id": 1,
    "text": "Что делает оператор :=?",
    "explanation": ":= — короткое объявление переменной: одновременно создаёт её и присваивает значение",
    "answers": [
      {
        "text": "Только объявляет переменную"
      },
      {
        "text": "Только присваивает уже существующей переменной"
      },
      {
        "text": "Объявляет и присваивает переменной значение",
        "correct": true
      },
      {
        "text": "Работает только внутри циклов"
      }
    ]
  },
  {
    "topic_id": 9,
    "text": "Какой размер буфера у небуферизированного канала?",
    "explanation": "Небуферизированный канал имеет буфер 0 — отправитель и получатель должны встретиться",
    "answers": [
      {
        "text": "0",
        "correct": true
      },
      {
        "text": "1"
      },
      {
        "text": "64"
      },
      {
        "text": "Размер зависит от системы"
      }
    ]
  },
  {
    "topic_id": 1,
    "text": "Какой оператор завершает выполнение текущей итерации цикла?",
    "explanation": "continue пропускает оставшийся код итерации и переходит к следующей",
    "answers": [
      {
        "text": "break"
      },
      {
        "text": "stop"
      },
      {
        "text": "continue",
        "correct": true
      },
      {
        "text": "skip"
      }
    ]
  },
  {
    "topic_id": 1,
    "text": "Что делает go перед вызовом функции?",
    "explanation": "go f() запускает функцию асинхронно в новой горутине",
    "answers": [
      {
        "text": "Ничего, просто синтаксический сахар"
      },
      {
        "text": "Компилирует функцию иначе"
      },
      {
        "text": "Запускает её в отдельной горутине",
        "correct": true
      },
      {
        "text": "Присваивает ей больший приоритет"
      }
    ]
  },
  {
    "topic_id": 1,
    "text": "Что делает функция panic?",
    "explanation": "panic запускает раскрутку стека в текущей горутине. Если не поймана recover, приложение завершится.panic всегда уничтожает только ту горутину, в которой произошла. Но если это главная горутина, то программа завершается.",
    "answers": [
      {
        "text": "Завершает только текущую горутину",
        "correct": true
      },
      {
        "text": "Мягко выводит сообщение об ошибке"
      },
      {
        "text": "Немедленно завершает программу"
      },
      {
        "text": "Запускает механизм ошибок без выхода из функции"
      }
    ]
  },
  {
    "topic_id": 1,
    "text": "Что всегда делает panic?",
    "explanation": "Если это главная горутина и паника не перехвачена, то программа завершиться.",
    "answers": [
      {
        "text": "Запускает раскрутку стека в текущей горутине",
        "correct": true
      },
      {
        "text": "Немедленно завершает программу"
      },
      {
        "text": "Завершает все горутины"
      },
      {
        "text": "Прерывает выполнение функции без вызова defer"
      }
    ]
  },
  {
    "topic_id": 12,
    "text": "В каком порядке выполняются несколько defer?",
    "explanation": "defer работает как стек — последний добавленный выполняется первым. (LIFO)",
    "answers": [
      {
        "text": "В порядке объявления"
      },
      {
        "text": "В случайном порядке"
      },
      {
        "text": "В обратном порядке",
        "correct": true
      },
      {
        "text": "Параллельно"
      }
    ]
  },
  {
    "topic_id": 12,
    "text": "Когда НЕ выполнится defer?",
    "explanation": "Объяснение: os.Exit() немедленно завершает программу, defer при этом не выполняется.",
    "answers": [
      {
        "text": "При return"
      },
      {
        "text": "При panic"
      },
      {
        "text": "При os.Exit()",
        "correct": true
      },
      {
        "text": "При выходе из main"
      }
    ]
  },
  {
    "topic_id": 12,
    "text": "Что выведет код?",
    "code": "for i := 0; i \u003c 3; i++ {\r\n    defer fmt.Print(i)\r\n}",
    "explanation": "Каждый defer получает своё значение i, а выполняются они в обратном порядке.",
    "answers": [
      {
        "text": "012"
      },
      {
        "text": "210",
        "correct": true
      },
      {
        "text": "333"
      },
      {
        "text": "000"
      }
    ]
  },
  {
    "topic_id": 12,
    "text": "Что выведет код?",
    "code": "x := 5\r\n\r\ndefer func() {\r\n    fmt.Println(x)\r\n}()\r\n\r\nx = 10",
    "explanation": "defer откладывает вызов функции, но не копирует значения переменных внутри замыкания.\r\nАнонимная функция замыкает переменную x, а не её значение.\r\nЗначение x берётся в момент выполнения defer, то есть при выходе из функции, а не при объявлении defer.",
    "answers": [
      {
        "text": "10",
        "correct": true
      },
      {
        "text": "5"
      },
      {
        "text": "компилятор выдаст ошибку"
      },
      {
        "text": "undefined behavior"
      }
    ]
  },
  {
    "topic_id": 12,
    "text": "Что выведет код?",
    "code": "x := 5\r\n\r\ndefer func(x int) {\r\n    fmt.Println(x)\r\n}(x)\r\n\r\nx = 10",
    "explanation": "Потому что значение x передаётся аргументом и копируется в момент defer.",
    "answers": [
      {
        "text": "5",
        "correct": true
      },
      {
        "text": "10"
      },
      {
        "text": "компилятор выдаст ошибку"
      },
      {
        "text": "undefined behavior"
      }
    ]
  },
  {
    "topic_id": 12,
    "text": "Что выведет код?",
    "code": "for i := 0; i \u003c 3; i++ {\r\n    defer func() {\r\n        fmt.Print(i)\r\n    }()\r\n}",
    "explanation": "Начиная с Go 1.22, переменная цикла i в for i := ... создаётся заново на каждой итерации, а не одна на весь цикл.",
    "answers": [
      {
        "text": "210"
      },
      {
        "text": "333"
      },
      {
        "text": "222"
      },
      {
        "text": "Зависит от версии Go",
        "correct": true
      }
    ]
  },
  {
    "topic_id": 1,
    "text": "Что выведет код?",
    "code": "x := 10\r\nf := func() {\r\n    fmt.Println(x)\r\n}\r\nx = 20\r\nf()",
    "explanation": "Замыкания захватывают переменные, а не значения",
    "answers": [
      {
        "text": "20",
        "correct": true
      },
      {
        "text": "10"
      },
      {
        "text": "undefined behavior"
      },
      {
        "text": "компилятор выдаст ошибку"
      }
    ]
  },
  {
    "topic_id": 1,
    "text": "Что выведет код?",
    "code": "var i int\r\nfor i = 0; i \u003c 3; i++ {\r\n    defer func() {\r\n        fmt.Print(i)\r\n    }()\r\n}",
    "explanation": "Потому что i не создаётся внутри цикла.",
    "answers": [
      {
        "text": "3 3 3",
        "correct": true
      },
      {
        "text": "0 1 2"
      },
      {
        "text": "2 1 0"
      },
      {
        "text": "2 2 2"
      }
    ]
  },
  {
    "topic_id": 1,
    "text": "Что выведет код?",
    "code": "x := 1\r\nf := func() { x++ }\r\ng := func() { x++ }\r\n\r\nf()\r\ng()\r\nfmt.Println(x)",
    "explanation": "одно storage, два замыкания",
    "answers": [
      {
        "text": "1"
      },
      {
        "text": "2"
      },
      {
        "text": "3",
        "correct": true
      },
      {
        "text": "Ошибка"
      }
    ]
  },
  {
    "topic_id": 12,
    "text": "Почему defer внутри цикла может быть опасен?",
    "explanation": "Каждый defer кладётся в стек — в длинных циклах это может привести к лишнему расходу памяти",
    "answers": [
      {
        "text": "Он не выполнится"
      },
      {
        "text": "Он выполняется сразу"
      },
      {
        "text": "Он накапливает вызовы и потребляет память",
        "correct": true
      },
      {
        "text": "Он ломает panic"
      }
    ]
  },
  {
    "topic_id": 12,
    "text": "Можно ли использовать defer в горутине?",
    "explanation": "defer привязан к текущей горутине и выполняется при её завершении",
    "answers": [
      {
        "text": "Нет"
      },
      {
        "text": "Да, но он выполнится в main"
      },
      {
        "text": "Да, он выполнится при выходе из горутины",
        "correct": true
      },
      {
        "text": "Только с WaitGroup"
      }
    ]
  },
  {
    "topic_id": 12,
    "text": "Что выведет код?",
    "code": "func f() {\r\n    defer fmt.Println(\"world\")\r\n    fmt.Println(\"hello\")\r\n}",
    "explanation": "Сначала выполняется обычный код, затем — defer",
    "answers": [
      {
        "text": "world hello"
      },
      {
        "text": "hello world",
        "correct": true
      },
      {
        "text": "Только hello"
      },
      {
        "text": "Только world"
      }
    ]
  },
  {
    "topic_id": 12,
    "text": "Где чаще всего используется defer?",
    "explanation": "defer идеально подходит для Close(), Unlock(), Recover() — гарантирует очистку ресурсов.",
    "answers": [
      {
        "text": "Для циклов"
      },
      {
        "text": "Для освобождения ресурсов",
        "correct": true
      },
      {
        "text": "Для ускорения кода"
      },
      {
        "text": "Для логирования только"
      }
    ]
  },
  {
    "topic_id": 12,
    "text": "Как defer ведёт себя с именованным return?",
    "code": "func f() (x int) {\r\n    defer func() {\r\n        x++\r\n    }()\r\n    return 1\r\n}",
    "explanation": "defer выполняется после присваивания return-значения, но до выхода из функции",
    "answers": [
      {
        "text": "Вернёт 1"
      },
      {
        "text": "Вернёт 2",
        "correct": true
      },
      {
        "text": "Вернёт 0"
      },
      {
        "text": "Паника"
      }
    ]
  },
  {
    "topic_id": 9,
    "text": "Что произойдёт при отправке в небуферизованный канал, если нет получателя?",
    "explanation": "Небуферизованный канал требует одновременного отправителя и получателя. Если получателя нет — горутина блокируется до его появления.",
    "answers": [
      {
        "text": "Значение потеряется"
      },
      {
        "text": "Отправка заблокируется",
        "correct": true
      },
      {
        "text": "Произойдёт panic"
      },
      {
        "text": "Значение будет записано в очередь планировщика"
      }
    ]
  },
  {
    "topic_id": 14,
    "text": "Что выведет код?",
    "code": "type Person struct {\r\n    Name string\r\n}\r\n\r\nfunc changeName(person *Person) {\r\n    person = \u0026Person{\"Mark\"}\r\n}\r\n\r\nfunc main() {\r\n    person := \u0026Person{\"Vad\"}\r\n    fmt.Println(person.Name)\r\n    changeName(person)\r\n    fmt.Println(person.Name)\r\n}",
    "explanation": "В функции указатель пересоздается.",
    "answers": [
      {
        "text": "Vad Vad",
        "correct": true
      },
      {
        "text": "Vad Mark"
      },
      {
        "text": "Mark Mark"
      },
      {
        "text": "Mark Vad"
      }
    ]
  },
  {
    "topic_id": 14,
    "text": "Что выведет код?",
    "code": "type Person struct {\r\n    Name string\r\n}\r\n\r\nfunc changeName(person *Person) {\r\n    *person = Person{\"Mark\"}\r\n}\r\n\r\nfunc main() {\r\n    person := Person{\"Vad\"}\r\n    fmt.Println(person.Name)\r\n    changeName(\u0026person)\r\n    fmt.Println(person.Name)\r\n}",
    "explanation": "У методе полная перезапись структуры, на которую указывает указатель",
    "answers": [
      {
        "text": "Vad Mark",
        "correct": true
      },
      {
        "text": "Vad Vad"
      },
      {
        "text": "Mark Mark"
      },
      {
        "text": "Mark Vad"
      }
    ]
  },
  {
    "topic_id": 9,
    "text": "Что произойдёт?",
    "code": "var ch chan int\r\nfmt.Println(\u003c-ch)",
    "explanation": "чтение из nil-канала блокирует навсегда.",
    "answers": [
      {
        "text": "Напечатает 0"
      },
      {
        "text": "Panic"
      },
      {
        "text": "Заблокируется навсегда",
        "correct": true
      },
      {
        "text": "Компилятор выдаст ошибку"
      }
    ]
  },
  {
    "topic_id": 9,
    "text": "Какой результат?",
    "code": "var ch chan int\r\nselect {\r\ncase ch \u003c- 1:\r\n    fmt.Println(\"send\")\r\ndefault:\r\n    fmt.Println(\"default\")\r\n}",
    "explanation": "nil-канал в select не выбирается → выполняется default",
    "answers": [
      {
        "text": "Panic"
      },
      {
        "text": "send"
      },
      {
        "text": "default",
        "correct": true
      },
      {
        "text": "Deadlock"
      }
    ]
  },
  {
    "topic_id": 9,
    "text": "Что произойдёт?",
    "code": "var ch chan int\r\nclose(ch)",
    "explanation": "close(nil) вызывает panic",
    "answers": [
      {
        "text": "Ничего"
      },
      {
        "text": "Канал закроется"
      },
      {
        "text": "Panic",
        "correct": true
      },
      {
        "text": "Deadlock"
      }
    ]
  },
  {
    "topic_id": 9,
    "text": "Чем nil-канал отличается от закрытого?",
    "explanation": "закрытый канал при чтении сразу возвращает (zero, false), nil — блокирует",
    "answers": [
      {
        "text": "Ничем"
      },
      {
        "text": "Закрытый блокирует чтение"
      },
      {
        "text": "nil возвращает zero-value"
      },
      {
        "text": "Закрытый сразу отдаёт значение",
        "correct": true
      }
    ]
  },
  {
    "topic_id": 9,
    "text": "Зачем разработчики используют nil-каналы?",
    "explanation": "nil-канал — стандартный паттерн для динамического управления select",
    "answers": [
      {
        "text": "Для экономии памяти"
      },
      {
        "text": "Чтобы отключать кейсы в select",
        "correct": true
      },
      {
        "text": "Для ускорения каналов"
      },
      {
        "text": "Чтобы избежать panic"
      }
    ]
  },
  {
    "topic_id": 2,
    "text": "Что выведет код?",
    "code": "a1 := make([]int, 0, 10)\r\na1 = append(a1, []int{1, 2, 3, 4, 5}...)\r\na2 := append(a1, 6)\r\na3 := append(a1, 7)\r\nfmt.Println(a1, a2, a3)",
    "explanation": "append возвращает новый срез, но не гарантирует новый массив.\r\nЕсли хватает capacity — данные будут общими.",
    "answers": [
      {
        "text": "[1 2 3 4 5] [1 2 3 4 5 7] [1 2 3 4 5 7]",
        "correct": true
      },
      {
        "text": "[1 2 3 4 5] [1 2 3 4 5 6] [1 2 3 4 5 7]"
      },
      {
        "text": "[1 2 3 4 5 6] [1 2 3 4 5 6] [1 2 3 4 5 7]"
      },
      {
        "text": "[1 2 3 4 5] [1 2 3 4 5 6] [1 2 3 4 5]"
      }
    ]
  },
  {
    "topic_id": 2,
    "text": "Что выведет код?",
    "code": "a1 := make([]int, 0)\r\na1 = append(a1, []int{1, 2, 3, 4, 5}...)\r\nfmt.Println(len(a1), cap(a1))",
    "explanation": "capacity после append НЕ обязана быть равна len. \r\nlen увеличился корректно, а cap \u003e= len\r\n",
    "answers": [
      {
        "text": "5 5"
      },
      {
        "text": "5 6"
      },
      {
        "text": "6 6"
      },
      {
        "text": "Определяется runtime",
        "correct": true
      }
    ]
  },
  {
    "topic_id": 17,
    "text": "Что из перечисленного верно про string в Go?",
    "explanation": "В Go string — это immutable последовательность байт, обычно с UTF-8 содержимым",
    "answers": [
      {
        "text": "string — изменяемый тип"
      },
      {
        "text": "string хранит UTF-16"
      },
      {
        "text": "string — неизменяемая последовательность байт",
        "correct": true
      },
      {
        "text": "string всегда ASCII"
      }
    ]
  },
  {
    "topic_id": 17,
    "text": "Что вернёт len(\"привет\")?",
    "explanation": "Каждый кириллический символ занимает 2 байта в UTF-8 → 6 × 2 = 12.",
    "answers": [
      {
        "text": "6"
      },
      {
        "text": "12",
        "correct": true
      },
      {
        "text": "5"
      },
      {
        "text": "Ошибку компиляции"
      }
    ]
  },
  {
    "topic_id": 17,
    "text": "Что такое rune?",
    "explanation": "rune = int32, используется для представления Unicode-символов",
    "answers": [
      {
        "text": "Алиас для byte"
      },
      {
        "text": "Тип для UTF-16 символов"
      },
      {
        "text": "Алиас для int32, представляющий Unicode code point",
        "correct": true
      },
      {
        "text": "Тип для строк"
      }
    ]
  },
  {
    "topic_id": 17,
    "text": "Что делает range при обходе строки?",
    "explanation": "range декодирует UTF-8 и возвращает rune",
    "answers": [
      {
        "text": "Идёт по байтам"
      },
      {
        "text": "Идёт по runes (Unicode code points)",
        "correct": true
      },
      {
        "text": "Идёт по словам"
      },
      {
        "text": "Идёт по grapheme clusters"
      }
    ]
  },
  {
    "topic_id": 17,
    "text": "Что означает индекс i в for i, r := range s?",
    "explanation": "i — это байтовый индекс начала rune в строке",
    "answers": [
      {
        "text": "Номер символа"
      },
      {
        "text": "Номер rune"
      },
      {
        "text": "Смещение в байтах",
        "correct": true
      },
      {
        "text": "Всегда 0,1,2..."
      }
    ]
  },
  {
    "topic_id": 17,
    "text": "Почему s += \"a\" в цикле — плохая идея?",
    "explanation": "Строки неизменяемы, каждое += создаёт новую строку",
    "answers": [
      {
        "text": "Может привести к deadlock"
      },
      {
        "text": "Создаёт много аллокаций",
        "correct": true
      },
      {
        "text": "Работает только с ASCII"
      },
      {
        "text": "Не компилируется"
      }
    ]
  },
  {
    "topic_id": 17,
    "text": "Какой способ конкатенации строк наиболее эффективен?",
    "explanation": "strings.Builder минимизирует аллокации",
    "answers": [
      {
        "text": "s += part"
      },
      {
        "text": "fmt.Sprintf"
      },
      {
        "text": "strings.Builder",
        "correct": true
      },
      {
        "text": "[]rune"
      }
    ]
  },
  {
    "topic_id": 17,
    "text": "Что произойдёт при s[0] = 'H'?",
    "explanation": "string в Go — неизменяемый тип",
    "answers": [
      {
        "text": "Строка изменится"
      },
      {
        "text": "Panic во время выполнения"
      },
      {
        "text": "Ошибка компиляции",
        "correct": true
      },
      {
        "text": "Ничего"
      }
    ]
  },
  {
    "topic_id": 17,
    "text": "Почему s[:2] может быть опасным для UTF-8 строки?",
    "explanation": "Срез строки идёт по байтам, а не по rune",
    "answers": [
      {
        "text": "Может вызвать panic"
      },
      {
        "text": "Работает медленно"
      },
      {
        "text": "Может разрезать символ",
        "correct": true
      },
      {
        "text": "Всегда возвращает пустую строку"
      }
    ]
  },
  {
    "topic_id": 17,
    "text": "Может ли string быть nil?",
    "explanation": "string — value type, нулевое значение — пустая строка \"\"",
    "answers": [
      {
        "text": "Да"
      },
      {
        "text": "Нет",
        "correct": true
      },
      {
        "text": "Только через unsafe"
      },
      {
        "text": "Только в map"
      }
    ]
  },
  {
    "topic_id": 11,
    "text": "Что представляет собой error в Go?",
    "explanation": "error — это интерфейс. Любой тип с методом Error() string считается ошибкой.",
    "answers": [
      {
        "text": "Специальный тип, встроенный в рантайм"
      },
      {
        "text": "Структура стандартной библиотеки"
      },
      {
        "text": "Интерфейс с методом Error() string",
        "correct": true
      },
      {
        "text": "Исключение, как в Java"
      }
    ]
  },
  {
    "topic_id": 11,
    "text": "Зачем используется %w в fmt.Errorf?",
    "explanation": "%w оборачивает ошибку, позволяя использовать errors.Is и errors.As",
    "answers": [
      {
        "text": "Для форматирования строки"
      },
      {
        "text": "Для логирования ошибки"
      },
      {
        "text": "Для передачи ошибки вверх без потери контекста",
        "correct": true
      },
      {
        "text": "Для создания panic"
      }
    ]
  },
  {
    "topic_id": 11,
    "text": "Что вернёт errors.Is(err, target)?",
    "explanation": "errors.Is проходит по всей цепочке wrapping",
    "answers": [
      {
        "text": "true, если строки ошибок совпадают"
      },
      {
        "text": "true, если err == target"
      },
      {
        "text": "true, если target есть в цепочке wrapped-ошибок",
        "correct": true
      },
      {
        "text": "true только для стандартных ошибок"
      }
    ]
  },
  {
    "topic_id": 11,
    "text": "Когда стоит использовать errors.As?",
    "explanation": "errors.As ищет ошибку нужного типа в цепочке",
    "answers": [
      {
        "text": "Для сравнения двух ошибок"
      },
      {
        "text": "Для извлечения конкретного типа ошибки",
        "correct": true
      },
      {
        "text": "Для логирования"
      },
      {
        "text": "Для замены panic"
      }
    ]
  },
  {
    "topic_id": 11,
    "text": "Что такое sentinel error?",
    "explanation": "Обычно объявляется как var ErrX = errors.New(...)",
    "answers": [
      {
        "text": "Ошибка с кодом"
      },
      {
        "text": "Именованная ошибка, сравниваемая через errors.Is",
        "correct": true
      },
      {
        "text": "Panic-ошибка"
      },
      {
        "text": "Временная ошибка"
      }
    ]
  },
  {
    "topic_id": 11,
    "text": "Где НЕ рекомендуется логировать ошибки?",
    "explanation": "Сервис возвращает ошибку вверх, логирование — на границе приложения.",
    "answers": [
      {
        "text": "В HTTP handler"
      },
      {
        "text": "В gRPC interceptor"
      },
      {
        "text": "В service слое",
        "correct": true
      },
      {
        "text": "В main"
      }
    ]
  },
  {
    "topic_id": 11,
    "text": "Как правильно проверить ошибку, возвращённую из БД?",
    "explanation": "Только errors.Is корректно работает с wrapped-ошибками",
    "answers": [
      {
        "text": "if err == sql.ErrNoRows"
      },
      {
        "text": "if err.Error() == \"no rows\""
      },
      {
        "text": "if errors.Is(err, sql.ErrNoRows)",
        "correct": true
      },
      {
        "text": "if err != nil \u0026\u0026 err == nil"
      }
    ]
  },
  {
    "topic_id": 11,
    "text": "В каком случае оправдано использование panic?",
    "explanation": "panic — для программистских ошибок, не для ожидаемых ситуаций",
    "answers": [
      {
        "text": "Пользователь ввёл неверные данные"
      },
      {
        "text": "Ошибка в бизнес-логике"
      },
      {
        "text": "Невозможное состояние или баг",
        "correct": true
      },
      {
        "text": "Ошибка сети"
      }
    ]
  },
  {
    "topic_id": 11,
    "text": "Что произойдёт, если использовать fmt.Errorf(\"err: %v\", err) вместо %w?",
    "explanation": "Без %w цепочка wrapping теряется",
    "answers": [
      {
        "text": "Ошибка станет быстрее"
      },
      {
        "text": "Ошибка будет залогирована"
      },
      {
        "text": "Потеряется информация о причине ошибки",
        "correct": true
      },
      {
        "text": "Ничего не изменится"
      }
    ]
  },
  {
    "topic_id": 11,
    "text": "Какой подход лучше всего подходит для доменных ошибок в DDD?",
    "explanation": "Типизированные ошибки хорошо расширяются и легко анализируются через errors.As",
    "answers": [
      {
        "text": "Только panic"
      },
      {
        "text": "Строковые ошибки"
      },
      {
        "text": "Кастомные типы ошибок",
        "correct": true
      },
      {
        "text": "Игнорирование ошибок"
      }
    ]
  },
  {
    "topic_id": 14,
    "text": "Что выведет код?",
    "code": "func inc(x int) {\r\n    x++\r\n}\r\n\r\nfunc main() {\r\n    a := 5\r\n    inc(a)\r\n    fmt.Println(a)\r\n}",
    "explanation": "В Go аргументы передаются по значению. x — копия a, оригинал не меняется.",
    "answers": [
      {
        "text": "6"
      },
      {
        "text": "5",
        "correct": true
      },
      {
        "text": "panic"
      },
      {
        "text": "undefined"
      }
    ]
  },
  {
    "topic_id": 14,
    "text": "Что выведет код?",
    "code": "func inc(x *int) {\r\n    *x++\r\n}\r\n\r\nfunc main() {\r\n    a := 5\r\n    inc(\u0026a)\r\n    fmt.Println(a)\r\n}",
    "explanation": "Передан указатель, функция меняет значение по адресу a",
    "answers": [
      {
        "text": "5"
      },
      {
        "text": "6",
        "correct": true
      },
      {
        "text": "panic"
      },
      {
        "text": "не скомпилируется"
      }
    ]
  },
  {
    "topic_id": 14,
    "text": "Что произойдёт при выполнении?",
    "code": "func f(p *int) {\r\n    p = nil\r\n}\r\n\r\nfunc main() {\r\n    a := 10\r\n    p := \u0026a\r\n    f(p)\r\n    fmt.Println(*p)\r\n}",
    "explanation": "p передаётся по значению. Внутри f меняется только локальная копия указателя",
    "answers": [
      {
        "text": "panic"
      },
      {
        "text": "10",
        "correct": true
      },
      {
        "text": "nil"
      },
      {
        "text": "не скомпилируется"
      }
    ]
  },
  {
    "topic_id": 14,
    "text": "Что выведет код?",
    "code": "type User struct {\r\n    Name string\r\n}\r\n\r\nfunc rename(u User) {\r\n    u.Name = \"Bob\"\r\n}\r\n\r\nfunc main() {\r\n    user := User{Name: \"Alice\"}\r\n    rename(user)\r\n    fmt.Println(user.Name)\r\n}",
    "explanation": "Передана копия структуры, оригинал не изменился.",
    "answers": [
      {
        "text": "Bob"
      },
      {
        "text": "Alice",
        "correct": true
      },
      {
        "text": "panic"
      },
      {
        "text": "пустую строку"
      }
    ]
  },
  {
    "topic_id": 14,
    "text": "Что выведет код?",
    "code": "type User struct {\r\n    Name string\r\n}\r\n\r\nfunc rename(u *User) {\r\n    u.Name = \"Bob\"\r\n}\r\n\r\nfunc main() {\r\n    user := User{Name: \"Alice\"}\r\n    rename(\u0026user)\r\n    fmt.Println(user.Name)\r\n}",
    "explanation": "Передан указатель, изменение происходит над оригинальным объектом.",
    "answers": [
      {
        "text": "Alice"
      },
      {
        "text": "Bob",
        "correct": true
      },
      {
        "text": "panic"
      },
      {
        "text": "undefined"
      }
    ]
  },
  {
    "topic_id": 14,
    "text": "Что из этого верно для Go?",
    "explanation": "В Go всё передаётся по значению, включая указатели.",
    "answers": [
      {
        "text": "В Go есть передача по ссылке"
      },
      {
        "text": "В Go есть только передача по значению",
        "correct": true
      },
      {
        "text": "Указатели передаются по ссылке"
      },
      {
        "text": "Структуры всегда передаются по ссылке"
      }
    ]
  },
  {
    "topic_id": 14,
    "text": "Почему говорят “указатели ≠ ссылки” в Go?",
    "explanation": "Указатель — это обычное значение с адресом, без скрытой магии.",
    "answers": [
      {
        "text": "Потому что указатели нельзя разыменовывать"
      },
      {
        "text": "Потому что ссылки работают быстрее"
      },
      {
        "text": "Потому что указатель — явное значение, а ссылка — неявная абстракция",
        "correct": true
      },
      {
        "text": "Потому что ссылки устарели"
      }
    ]
  },
  {
    "topic_id": 14,
    "text": "Что передаётся в функцию при вызове f(\u0026x)?",
    "explanation": "Передаётся копия указателя, но он указывает на тот же адрес.",
    "answers": [
      {
        "text": "Сам объект x"
      },
      {
        "text": "Ссылка на x"
      },
      {
        "text": "Копия указателя на x",
        "correct": true
      },
      {
        "text": "Адрес функции f"
      }
    ]
  },
  {
    "topic_id": 14,
    "text": "Почему Go-дизайн с указателями важен для concurrency?",
    "explanation": "Явность владения данными упрощает reasoning в многопоточности",
    "answers": [
      {
        "text": "Потому что указатели потокобезопасны"
      },
      {
        "text": "Потому что убирает неявные изменения данных",
        "correct": true
      },
      {
        "text": "Потому что запрещает shared state"
      },
      {
        "text": "Потому что ускоряет GC"
      }
    ]
  },
  {
    "topic_id": 14,
    "text": "Когда использование указателя оправдано?",
    "explanation": "Указатели нужны по делу, а не «на всякий случай»",
    "answers": [
      {
        "text": "Всегда"
      },
      {
        "text": "Никогда"
      },
      {
        "text": "Когда нужно изменить объект или избежать копирования",
        "correct": true
      },
      {
        "text": "Только для примитивов"
      }
    ]
  },
  {
    "topic_id": 18,
    "text": "С какого релиза в Go появились Generics?",
    "explanation": "Generics официально добавлены в Go 1.18",
    "answers": [
      {
        "text": "Go 1.16"
      },
      {
        "text": "Go 1.17"
      },
      {
        "text": "Go 1.18",
        "correct": true
      },
      {
        "text": "Go 1.20"
      }
    ]
  },
  {
    "topic_id": 18,
    "text": "Что означает T any в сигнатуре функции?",
    "explanation": "any — это alias для interface{}",
    "answers": [
      {
        "text": "T — любой интерфейс"
      },
      {
        "text": "T — указатель"
      },
      {
        "text": "T — любой тип",
        "correct": true
      },
      {
        "text": "T — алиас struct{}"
      }
    ]
  },
  {
    "topic_id": 18,
    "text": "Чем Generics принципиально лучше interface{}?",
    "explanation": "Главное преимущество — типобезопасность на этапе",
    "answers": [
      {
        "text": "Быстрее на этапе выполнения"
      },
      {
        "text": "Проверка типов на compile-time",
        "correct": true
      },
      {
        "text": "Меньше кода"
      },
      {
        "text": "Работают с reflection"
      }
    ]
  },
  {
    "topic_id": 18,
    "text": "Можно ли использовать операторы (+, ==) с T any?",
    "explanation": "Без constraint компилятор не знает, какие операции разрешены.",
    "answers": [
      {
        "text": "Да, всегда"
      },
      {
        "text": "Да, если тип известен"
      },
      {
        "text": "Только через reflection"
      },
      {
        "text": "Нет, нужен constraint",
        "correct": true
      }
    ]
  },
  {
    "topic_id": 18,
    "text": "Заменяют ли Generics интерфейсы в Go?",
    "explanation": "Generics — про данные, интерфейсы — про поведение",
    "answers": [
      {
        "text": "Да"
      },
      {
        "text": "Частично"
      },
      {
        "text": "Только в структурах"
      },
      {
        "text": "Нет",
        "correct": true
      }
    ]
  },
  {
    "topic_id": 18,
    "text": "Скомпилируется ли код?",
    "code": "func Add[T any](a, b T) T {\r\n    return a + b\r\n}",
    "explanation": "any не гарантирует наличие оператора +",
    "answers": [
      {
        "text": "Да"
      },
      {
        "text": "Нет",
        "correct": true
      },
      {
        "text": "Зависит от T"
      },
      {
        "text": "Неопределенное поводение"
      }
    ]
  },
  {
    "topic_id": 18,
    "text": "Что не так с этим кодом?",
    "code": "type Box[T any] struct {\r\n    Value T\r\n}\r\n\r\nfunc (b Box[T]) Map[R any](f func(T) R) R {\r\n    return f(b.Value)\r\n}",
    "explanation": "В Go методы не могут объявлять свои generic-параметры",
    "answers": [
      {
        "text": "Ошибка синтаксиса"
      },
      {
        "text": "Нельзя использовать generics в методах"
      },
      {
        "text": "Метод не может иметь собственный тип-параметр",
        "correct": true
      },
      {
        "text": "Всё корректно"
      }
    ]
  },
  {
    "topic_id": 18,
    "text": "Скомпилируется ли вызов?",
    "code": "func Identity[T any](v T) T { return v }\r\n\r\nvar x any = 10\r\nIdentity(x)",
    "explanation": "Тип T выводится как any, а не int",
    "answers": [
      {
        "text": "Да, вернёт int"
      },
      {
        "text": "Да, вернёт any",
        "correct": true
      },
      {
        "text": "Нет"
      },
      {
        "text": "С panic"
      }
    ]
  },
  {
    "topic_id": 18,
    "text": "Скомпилируется ли код?",
    "code": "func Equal[T comparable](a, b T) bool {\r\n    return a == b\r\n}\r\n\r\nEqual([]int{1}, []int{1})",
    "explanation": "slice не comparable, даже если элементы comparable",
    "answers": [
      {
        "text": "Да"
      },
      {
        "text": "Нет",
        "correct": true
      },
      {
        "text": "Panic"
      },
      {
        "text": "Неопределенное поведение"
      }
    ]
  },
  {
    "topic_id": 18,
    "text": "Что выведет программа?",
    "code": "func Print[T any](v T) {\r\n    fmt.Printf(\"%T\\n\", v)\r\n}\r\n\r\nPrint(10)\r\nPrint(\"hi\")",
    "explanation": "Generic подставляет конкретный тип, не стирая его",
    "answers": [
      {
        "text": "T и T"
      },
      {
        "text": "any и any"
      },
      {
        "text": "int и string",
        "correct": true
      },
      {
        "text": "Ошибка компиляции"
      }
    ]
  }
]