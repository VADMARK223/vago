[
  {
    "topic_id": 2,
    "text": "Что напечатает код?",
    "code": "s := []int{5, 6, 7}\ns2 := append(append(s, 8), 9)\nfmt.Println(len(s), cap(s))\n",
    "explanation": "append(s, 8) уже создало новый массив, но переменная s осталась нетронутой.",
    "answers": [
      {
        "text": "3 3",
        "correct": true
      },
      {
        "text": "3 4"
      },
      {
        "text": "3 6"
      },
      {
        "text": "3 8"
      }
    ]
  },
  {
    "topic_id": 2,
    "text": "Что напечатает код?",
    "code": "s := []int{1, 2, 3}\ns2 := s[:1] // len=1, cap=3\ns3 := append(s2, 9)\nfmt.Println(s, s3)\n",
    "explanation": "append пишет в общую память: срез s тоже меняется.",
    "answers": [
      {
        "text": "[1 2 3] [1 9]"
      },
      {
        "text": "[1 9 3] [1 9]",
        "correct": true
      },
      {
        "text": "[1 9 3] [1 9 3]"
      },
      {
        "text": "[1 2 3] [1 2 3 9]"
      }
    ]
  },
  {
    "topic_id": 2,
    "text": "Что напечатает код?",
    "code": "s := make([]int, 2, 5)\ns2 := append(s, 7)\ns2[0] = 99\nfmt.Println(s[0])\n",
    "explanation": "Общий массив, так как при append вместимости хватает (5)",
    "answers": [
      {
        "text": "99",
        "correct": true
      },
      {
        "text": "0"
      },
      {
        "text": "7"
      },
      {
        "text": "Panic"
      }
    ]
  },
  {
    "topic_id": 2,
    "text": "Что напечатает код?",
    "code": "s := []int{10, 20, 30}\ns2 := s[:2]\ns2[1] = 99\nfmt.Println(s[1])\n",
    "explanation": "Подзрезка тоже же базового массива.\nПосле подрезки в s2 [10 20], len=2, cap=3",
    "answers": [
      {
        "text": "99",
        "correct": true
      },
      {
        "text": "20"
      },
      {
        "text": "30"
      },
      {
        "text": "Panic"
      }
    ]
  },
  {
    "topic_id": 2,
    "text": "Что напечатает код?",
    "code": "s := []int{1, 2, 3}\ns2 := append(s, 4)\ns2[0] = 99\nfmt.Println(s[0])\n",
    "explanation": "В начале len=3 cap=3, под срезом лежит массив [1 2 3]\nПосле добавления 4, нет свободного места создается НОВЫЙ базовый массив с cap=6, изменения идут уже у нового массива",
    "answers": [
      {
        "text": "1",
        "correct": true
      },
      {
        "text": "99"
      },
      {
        "text": "Runtime panic"
      },
      {
        "text": "Зависит от версии Go"
      }
    ]
  },
  {
    "topic_id": 9,
    "text": "Что произойдёт при исполнении?",
    "code": "ch := make(chan int)\ngo func() {\n\tch \u003c- 10\n}()\nfmt.Println(\u003c-ch)\n",
    "explanation": "Обычная синхронная передача данных.",
    "answers": [
      {
        "text": "Deadlock"
      },
      {
        "text": "10",
        "correct": true
      },
      {
        "text": "Panic: closed channel"
      },
      {
        "text": "Неопределенное поведение"
      }
    ]
  },
  {
    "topic_id": 4,
    "text": "Что выведет код?",
    "code": "m := make(map[string]int)\nm[\"a\"] = 1\nfor k := range m {\n\tdelete(m, k)\n}\nfmt.Println(len(m))\n",
    "explanation": "Go допускает удаление элементов из map во время итерации.",
    "answers": [
      {
        "text": "1"
      },
      {
        "text": "0",
        "correct": true
      },
      {
        "text": "panic"
      },
      {
        "text": "Неопределенное поведение"
      }
    ]
  },
  {
    "topic_id": 11,
    "text": "Для чего нужен интерфейс error?",
    "answers": [
      {
        "text": "Для обработки исключений"
      },
      {
        "text": "Для передачи ошибок как значений",
        "correct": true
      },
      {
        "text": "Чтобы логировать ошибки автоматически"
      },
      {
        "text": "Чтобы завершать программу"
      }
    ]
  },
  {
    "topic_id": 9,
    "text": "Какая коллекция в Go является потокобезопасной по умолчанию?",
    "answers": [
      {
        "text": "Map"
      },
      {
        "text": "Slice"
      },
      {
        "text": "Channel",
        "correct": true
      },
      {
        "text": "Array"
      }
    ]
  },
  {
    "topic_id": 9,
    "text": "Какой тип передается в канал chan int?",
    "answers": [
      {
        "text": "Только указатели на int"
      },
      {
        "text": "Только значения типа int",
        "correct": true
      },
      {
        "text": "Любые числа"
      },
      {
        "text": "Любые типы"
      }
    ]
  },
  {
    "topic_id": 9,
    "text": "Что произойдёт при записи в закрытый канал?",
    "answers": [
      {
        "text": "Ничего — значение игнорируется"
      },
      {
        "text": "Запись блокируется"
      },
      {
        "text": "Происходит panic",
        "correct": true
      },
      {
        "text": "Возвращается zero-value"
      }
    ]
  },
  {
    "topic_id": 13,
    "text": "Когда происходит escape в heap?",
    "answers": [
      {
        "text": "Когда переменная слишком большая"
      },
      {
        "text": "Когда значение нужно вернуть наружу и оно \"живет\" после выхода функции",
        "correct": true
      },
      {
        "text": "Когда в функции много переменных"
      },
      {
        "text": "Когда программа вызывает panic"
      }
    ]
  },
  {
    "topic_id": 7,
    "text": "Что такое goroutine?",
    "explanation": "Горутина в Go стартует с динамическим стеком ~2 KB плюс несколько сотен байт служебных структур runtime, итого ~2–4 KB. Стек растёт и сжимается автоматически.",
    "answers": [
      {
        "text": "Отдельный процесс ОС"
      },
      {
        "text": "Лёгкая потокоподобная сущность, управляемая рантаймом Go",
        "correct": true
      },
      {
        "text": "Поток ОС"
      },
      {
        "text": "Операция ввода-вывода"
      }
    ]
  },
  {
    "topic_id": 12,
    "text": "Что делает ключевое слово defer?",
    "explanation": "Откладывает выполнение функции до момента выхода из текущей функции (в том числе при return, панике, или обычном завершении).",
    "answers": [
      {
        "text": "Выполняет функцию асинхронно"
      },
      {
        "text": "Выполняет функцию после выхода из текущей функции",
        "correct": true
      },
      {
        "text": "Отменяет выполнение функции"
      },
      {
        "text": "Экспортирует функцию"
      }
    ]
  },
  {
    "topic_id": 5,
    "text": "Какой размер у пустой структуры struct{}?",
    "answers": [
      {
        "text": "1 байт"
      },
      {
        "text": "0 байт",
        "correct": true
      },
      {
        "text": "4 байта"
      },
      {
        "text": "Зависит от архитектуры"
      }
    ]
  },
  {
    "topic_id": 2,
    "text": "Что выведет код?",
    "code": "s1 := []int{1, 2, 3}\r\ns2 := make([]int, 3)\r\ncopy(s2, s1)\r\ns2[0] = 99\r\nfmt.Println(s1[0])",
    "explanation": "copy создаёт независимые массивы (если заранее выделена память). Изменения в s2 не влияют на s1.",
    "answers": [
      {
        "text": "1",
        "correct": true
      },
      {
        "text": "99"
      },
      {
        "text": "Зависит от компилятора"
      },
      {
        "text": "panic"
      }
    ]
  },
  {
    "topic_id": 2,
    "text": "Что выведет код?",
    "code": "s1 := []int{10, 20, 30}\r\ns2 := s1[:2]\r\ncopy(s2, []int{7})\r\nfmt.Println(s1)",
    "explanation": "s2 — подрезка того же массива. copy пишет в базовый массив.",
    "answers": [
      {
        "text": "[10 20 30]"
      },
      {
        "text": "[7 20 30]",
        "correct": true
      },
      {
        "text": "[7 7 30]"
      },
      {
        "text": "[7 20]"
      }
    ]
  },
  {
    "topic_id": 2,
    "text": "Что выведет код?",
    "code": "s1 := []int{1, 2, 3, 4}\r\ns2 := make([]int, 0, 4)\r\nn := copy(s2, s1)\r\nfmt.Println(n, len(s2), cap(s2))",
    "explanation": "copy копирует минимум(len(dst), len(src)).\r\nlen(dst) = 0 ⇒ копируется 0 элементов.",
    "answers": [
      {
        "text": "4 4 4"
      },
      {
        "text": "4 0 4"
      },
      {
        "text": "0 0 4",
        "correct": true
      },
      {
        "text": "panic"
      }
    ]
  },
  {
    "topic_id": 2,
    "text": "Что выведет код?",
    "code": "s1 := []int{1, 2, 3}\r\ns2 := make([]int, 5)\r\ncopy(s2, s1)\r\ns1 = append(s1, 9)\r\nfmt.Println(s2)",
    "explanation": "s2 — независимый массив.\r\nappend(s1, 9) создаёт новый массив (cap == len) и не влияет на s2.",
    "answers": [
      {
        "text": "[1 2 3 0 0]",
        "correct": true
      },
      {
        "text": "[1 2 3 9 0]"
      },
      {
        "text": "[1 2 3 0 9]"
      },
      {
        "text": "[9 2 3 0 0]"
      }
    ]
  },
  {
    "topic_id": 2,
    "text": "Что выведет код?",
    "code": "s1 := []int{5, 6, 7, 8}\r\ns2 := s1[1:3] // [6 7]\r\ns3 := make([]int, 2)\r\ncopy(s3, s2)\r\ns2[0] = 99\r\nfmt.Println(s1, s3)",
    "explanation": "s2 ссылается на тот же массив, что и s1.\r\ns3 — независимая копия.",
    "answers": [
      {
        "text": "[5 6 7 8] [6 7]"
      },
      {
        "text": "[5 99 7 8] [6 7]",
        "correct": true
      },
      {
        "text": "[5 99 7 8] [99 7]"
      },
      {
        "text": "[5 6 7 8] [99 7]"
      }
    ]
  },
  {
    "topic_id": 12,
    "text": "Что выведет Go?",
    "code": "x := 5\r\ndefer fmt.Println(x)\r\nx = 10",
    "explanation": "Аргументы defer вычисляются в момент его объявления.",
    "answers": [
      {
        "text": "5",
        "correct": true
      },
      {
        "text": "10"
      },
      {
        "text": "компилятор выдаст ошибку"
      },
      {
        "text": "undefined behavior"
      }
    ]
  },
  {
    "topic_id": 1,
    "text": "Что произойдёт, если читать из закрытого канала?",
    "explanation": "Чтение из закрытого канала безопасно: возвращается zero-value и флаг ok=false.",
    "answers": [
      {
        "text": "Возникнет паника"
      },
      {
        "text": "Горутина заблокируется навсегда"
      },
      {
        "text": "Вернётся нулевое значение типа и ok=false",
        "correct": true
      },
      {
        "text": "Чтение будет проигнорировано"
      }
    ]
  },
  {
    "topic_id": 1,
    "text": "Какой тип используется по умолчанию для неинициализированной переменной int?",
    "explanation": "Все переменные в Go инициализируются нулевыми значениями, для int — это 0",
    "answers": [
      {
        "text": "nil"
      },
      {
        "text": "undefined"
      },
      {
        "text": "0",
        "correct": true
      },
      {
        "text": "Минимальное значение int"
      }
    ]
  },
  {
    "topic_id": 1,
    "text": "Что означает «race condition» в Go?",
    "explanation": "«Гонка данных» — состояние, когда несколько горутин одновременно обращаются к разделяемым данным без синхронизации.",
    "answers": [
      {
        "text": "Ошибка синтаксиса"
      },
      {
        "text": "Конкурентное обновление общей переменной",
        "correct": true
      },
      {
        "text": "Некорректная работа GC"
      },
      {
        "text": "Ошибка сборки"
      }
    ]
  },
  {
    "topic_id": 1,
    "text": "Что делает оператор :=?",
    "explanation": ":= — короткое объявление переменной: одновременно создаёт её и присваивает значение",
    "answers": [
      {
        "text": "Только объявляет переменную"
      },
      {
        "text": "Только присваивает уже существующей переменной"
      },
      {
        "text": "Объявляет и присваивает переменной значение",
        "correct": true
      },
      {
        "text": "Работает только внутри циклов"
      }
    ]
  },
  {
    "topic_id": 9,
    "text": "Какой размер буфера у небуферизированного канала?",
    "explanation": "Небуферизированный канал имеет буфер 0 — отправитель и получатель должны встретиться",
    "answers": [
      {
        "text": "0",
        "correct": true
      },
      {
        "text": "1"
      },
      {
        "text": "64"
      },
      {
        "text": "Размер зависит от системы"
      }
    ]
  },
  {
    "topic_id": 1,
    "text": "Какой оператор завершает выполнение текущей итерации цикла?",
    "explanation": "continue пропускает оставшийся код итерации и переходит к следующей",
    "answers": [
      {
        "text": "break"
      },
      {
        "text": "stop"
      },
      {
        "text": "continue",
        "correct": true
      },
      {
        "text": "skip"
      }
    ]
  },
  {
    "topic_id": 1,
    "text": "Что делает go перед вызовом функции?",
    "explanation": "go f() запускает функцию асинхронно в новой горутине",
    "answers": [
      {
        "text": "Ничего, просто синтаксический сахар"
      },
      {
        "text": "Компилирует функцию иначе"
      },
      {
        "text": "Запускает её в отдельной горутине",
        "correct": true
      },
      {
        "text": "Присваивает ей больший приоритет"
      }
    ]
  },
  {
    "topic_id": 1,
    "text": "Что делает функция panic?",
    "explanation": "panic запускает раскрутку стека в текущей горутине. Если не поймана recover, приложение завершится.panic всегда уничтожает только ту горутину, в которой произошла. Но если это главная горутина, то программа завершается.",
    "answers": [
      {
        "text": "Завершает только текущую горутину",
        "correct": true
      },
      {
        "text": "Мягко выводит сообщение об ошибке"
      },
      {
        "text": "Немедленно завершает программу"
      },
      {
        "text": "Запускает механизм ошибок без выхода из функции"
      }
    ]
  },
  {
    "topic_id": 1,
    "text": "Что всегда делает panic?",
    "explanation": "Если это главная горутина и паника не перехвачена, то программа завершиться.",
    "answers": [
      {
        "text": "Запускает раскрутку стека в текущей горутине",
        "correct": true
      },
      {
        "text": "Немедленно завершает программу"
      },
      {
        "text": "Завершает все горутины"
      },
      {
        "text": "Прерывает выполнение функции без вызова defer"
      }
    ]
  },
  {
    "topic_id": 12,
    "text": "В каком порядке выполняются несколько defer?",
    "explanation": "defer работает как стек — последний добавленный выполняется первым. (LIFO)",
    "answers": [
      {
        "text": "В порядке объявления"
      },
      {
        "text": "В случайном порядке"
      },
      {
        "text": "В обратном порядке",
        "correct": true
      },
      {
        "text": "Параллельно"
      }
    ]
  },
  {
    "topic_id": 12,
    "text": "Когда НЕ выполнится defer?",
    "explanation": "Объяснение: os.Exit() немедленно завершает программу, defer при этом не выполняется.",
    "answers": [
      {
        "text": "При return"
      },
      {
        "text": "При panic"
      },
      {
        "text": "При os.Exit()",
        "correct": true
      },
      {
        "text": "При выходе из main"
      }
    ]
  },
  {
    "topic_id": 12,
    "text": "Что выведет код?",
    "code": "for i := 0; i \u003c 3; i++ {\r\n    defer fmt.Print(i)\r\n}",
    "explanation": "Каждый defer получает своё значение i, а выполняются они в обратном порядке.",
    "answers": [
      {
        "text": "012"
      },
      {
        "text": "210",
        "correct": true
      },
      {
        "text": "333"
      },
      {
        "text": "000"
      }
    ]
  },
  {
    "topic_id": 12,
    "text": "Что выведет код?",
    "code": "x := 5\r\n\r\ndefer func() {\r\n    fmt.Println(x)\r\n}()\r\n\r\nx = 10",
    "explanation": "defer откладывает вызов функции, но не копирует значения переменных внутри замыкания.\r\nАнонимная функция замыкает переменную x, а не её значение.\r\nЗначение x берётся в момент выполнения defer, то есть при выходе из функции, а не при объявлении defer.",
    "answers": [
      {
        "text": "10",
        "correct": true
      },
      {
        "text": "5"
      },
      {
        "text": "компилятор выдаст ошибку"
      },
      {
        "text": "undefined behavior"
      }
    ]
  },
  {
    "topic_id": 12,
    "text": "Что выведет код?",
    "code": "x := 5\r\n\r\ndefer func(x int) {\r\n    fmt.Println(x)\r\n}(x)\r\n\r\nx = 10",
    "explanation": "Потому что значение x передаётся аргументом и копируется в момент defer.",
    "answers": [
      {
        "text": "5",
        "correct": true
      },
      {
        "text": "10"
      },
      {
        "text": "компилятор выдаст ошибку"
      },
      {
        "text": "undefined behavior"
      }
    ]
  },
  {
    "topic_id": 12,
    "text": "Что выведет код?",
    "code": "for i := 0; i \u003c 3; i++ {\r\n    defer func() {\r\n        fmt.Print(i)\r\n    }()\r\n}",
    "explanation": "Начиная с Go 1.22, переменная цикла i в for i := ... создаётся заново на каждой итерации, а не одна на весь цикл.",
    "answers": [
      {
        "text": "210"
      },
      {
        "text": "333"
      },
      {
        "text": "222"
      },
      {
        "text": "Зависит от версии Go",
        "correct": true
      }
    ]
  },
  {
    "topic_id": 1,
    "text": "Что выведет код?",
    "code": "x := 10\r\nf := func() {\r\n    fmt.Println(x)\r\n}\r\nx = 20\r\nf()",
    "explanation": "Замыкания захватывают переменные, а не значения",
    "answers": [
      {
        "text": "20",
        "correct": true
      },
      {
        "text": "10"
      },
      {
        "text": "undefined behavior"
      },
      {
        "text": "компилятор выдаст ошибку"
      }
    ]
  },
  {
    "topic_id": 1,
    "text": "Что выведет код?",
    "code": "var i int\r\nfor i = 0; i \u003c 3; i++ {\r\n    defer func() {\r\n        fmt.Print(i)\r\n    }()\r\n}",
    "explanation": "Потому что i не создаётся внутри цикла.",
    "answers": [
      {
        "text": "3 3 3",
        "correct": true
      },
      {
        "text": "0 1 2"
      },
      {
        "text": "2 1 0"
      },
      {
        "text": "2 2 2"
      }
    ]
  },
  {
    "topic_id": 1,
    "text": "Что выведет код?",
    "code": "x := 1\r\nf := func() { x++ }\r\ng := func() { x++ }\r\n\r\nf()\r\ng()\r\nfmt.Println(x)",
    "explanation": "одно storage, два замыкания",
    "answers": [
      {
        "text": "1"
      },
      {
        "text": "2"
      },
      {
        "text": "3",
        "correct": true
      },
      {
        "text": "Ошибка"
      }
    ]
  },
  {
    "topic_id": 12,
    "text": "Почему defer внутри цикла может быть опасен?",
    "explanation": "Каждый defer кладётся в стек — в длинных циклах это может привести к лишнему расходу памяти",
    "answers": [
      {
        "text": "Он не выполнится"
      },
      {
        "text": "Он выполняется сразу"
      },
      {
        "text": "Он накапливает вызовы и потребляет память",
        "correct": true
      },
      {
        "text": "Он ломает panic"
      }
    ]
  },
  {
    "topic_id": 12,
    "text": "Можно ли использовать defer в горутине?",
    "explanation": "defer привязан к текущей горутине и выполняется при её завершении",
    "answers": [
      {
        "text": "Нет"
      },
      {
        "text": "Да, но он выполнится в main"
      },
      {
        "text": "Да, он выполнится при выходе из горутины",
        "correct": true
      },
      {
        "text": "Только с WaitGroup"
      }
    ]
  },
  {
    "topic_id": 12,
    "text": "Что выведет код?",
    "code": "func f() {\r\n    defer fmt.Println(\"world\")\r\n    fmt.Println(\"hello\")\r\n}",
    "explanation": "Сначала выполняется обычный код, затем — defer",
    "answers": [
      {
        "text": "world hello"
      },
      {
        "text": "hello world",
        "correct": true
      },
      {
        "text": "Только hello"
      },
      {
        "text": "Только world"
      }
    ]
  },
  {
    "topic_id": 12,
    "text": "Где чаще всего используется defer?",
    "explanation": "defer идеально подходит для Close(), Unlock(), Recover() — гарантирует очистку ресурсов.",
    "answers": [
      {
        "text": "Для циклов"
      },
      {
        "text": "Для освобождения ресурсов",
        "correct": true
      },
      {
        "text": "Для ускорения кода"
      },
      {
        "text": "Для логирования только"
      }
    ]
  },
  {
    "topic_id": 12,
    "text": "Как defer ведёт себя с именованным return?",
    "code": "func f() (x int) {\r\n    defer func() {\r\n        x++\r\n    }()\r\n    return 1\r\n}",
    "explanation": "defer выполняется после присваивания return-значения, но до выхода из функции",
    "answers": [
      {
        "text": "Вернёт 1"
      },
      {
        "text": "Вернёт 2",
        "correct": true
      },
      {
        "text": "Вернёт 0"
      },
      {
        "text": "Паника"
      }
    ]
  },
  {
    "topic_id": 9,
    "text": "Что произойдёт при отправке в небуферизованный канал, если нет получателя?",
    "explanation": "Небуферизованный канал требует одновременного отправителя и получателя. Если получателя нет — горутина блокируется до его появления.",
    "answers": [
      {
        "text": "Значение потеряется"
      },
      {
        "text": "Отправка заблокируется",
        "correct": true
      },
      {
        "text": "Произойдёт panic"
      },
      {
        "text": "Значение будет записано в очередь планировщика"
      }
    ]
  },
  {
    "topic_id": 14,
    "text": "Что выведет код?",
    "code": "type Person struct {\r\n    Name string\r\n}\r\n\r\nfunc changeName(person *Person) {\r\n    person = \u0026Person{\"Mark\"}\r\n}\r\n\r\nfunc main() {\r\n    person := \u0026Person{\"Vad\"}\r\n    fmt.Println(person.Name)\r\n    changeName(person)\r\n    fmt.Println(person.Name)\r\n}",
    "explanation": "В функции указатель пересоздается.",
    "answers": [
      {
        "text": "Vad Vad",
        "correct": true
      },
      {
        "text": "Vad Mark"
      },
      {
        "text": "Mark Mark"
      },
      {
        "text": "Mark Vad"
      }
    ]
  },
  {
    "topic_id": 14,
    "text": "Что выведет код?",
    "code": "type Person struct {\r\n    Name string\r\n}\r\n\r\nfunc changeName(person *Person) {\r\n    *person = Person{\"Mark\"}\r\n}\r\n\r\nfunc main() {\r\n    person := Person{\"Vad\"}\r\n    fmt.Println(person.Name)\r\n    changeName(\u0026person)\r\n    fmt.Println(person.Name)\r\n}",
    "explanation": "У методе полная перезапись структуры, на которую указывает указатель",
    "answers": [
      {
        "text": "Vad Mark",
        "correct": true
      },
      {
        "text": "Vad Vad"
      },
      {
        "text": "Mark Mark"
      },
      {
        "text": "Mark Vad"
      }
    ]
  },
  {
    "topic_id": 9,
    "text": "Что произойдёт?",
    "code": "var ch chan int\r\nfmt.Println(\u003c-ch)",
    "explanation": "чтение из nil-канала блокирует навсегда.",
    "answers": [
      {
        "text": "Напечатает 0"
      },
      {
        "text": "Panic"
      },
      {
        "text": "Заблокируется навсегда",
        "correct": true
      },
      {
        "text": "Компилятор выдаст ошибку"
      }
    ]
  },
  {
    "topic_id": 9,
    "text": "Какой результат?",
    "code": "var ch chan int\r\nselect {\r\ncase ch \u003c- 1:\r\n    fmt.Println(\"send\")\r\ndefault:\r\n    fmt.Println(\"default\")\r\n}",
    "explanation": "nil-канал в select не выбирается → выполняется default",
    "answers": [
      {
        "text": "Panic"
      },
      {
        "text": "send"
      },
      {
        "text": "default",
        "correct": true
      },
      {
        "text": "Deadlock"
      }
    ]
  },
  {
    "topic_id": 9,
    "text": "Что произойдёт?",
    "code": "var ch chan int\r\nclose(ch)",
    "explanation": "close(nil) вызывает panic",
    "answers": [
      {
        "text": "Ничего"
      },
      {
        "text": "Канал закроется"
      },
      {
        "text": "Panic",
        "correct": true
      },
      {
        "text": "Deadlock"
      }
    ]
  },
  {
    "topic_id": 9,
    "text": "Чем nil-канал отличается от закрытого?",
    "explanation": "закрытый канал при чтении сразу возвращает (zero, false), nil — блокирует",
    "answers": [
      {
        "text": "Ничем"
      },
      {
        "text": "Закрытый блокирует чтение"
      },
      {
        "text": "nil возвращает zero-value"
      },
      {
        "text": "Закрытый сразу отдаёт значение",
        "correct": true
      }
    ]
  },
  {
    "topic_id": 9,
    "text": "Зачем разработчики используют nil-каналы?",
    "explanation": "nil-канал — стандартный паттерн для динамического управления select",
    "answers": [
      {
        "text": "Для экономии памяти"
      },
      {
        "text": "Чтобы отключать кейсы в select",
        "correct": true
      },
      {
        "text": "Для ускорения каналов"
      },
      {
        "text": "Чтобы избежать panic"
      }
    ]
  },
  {
    "topic_id": 2,
    "text": "Что выведет код?",
    "code": "a1 := make([]int, 0, 10)\r\na1 = append(a1, []int{1, 2, 3, 4, 5}...)\r\na2 := append(a1, 6)\r\na3 := append(a1, 7)\r\nfmt.Println(a1, a2, a3)",
    "explanation": "append возвращает новый срез, но не гарантирует новый массив.\r\nЕсли хватает capacity — данные будут общими.",
    "answers": [
      {
        "text": "[1 2 3 4 5] [1 2 3 4 5 7] [1 2 3 4 5 7]",
        "correct": true
      },
      {
        "text": "[1 2 3 4 5] [1 2 3 4 5 6] [1 2 3 4 5 7]"
      },
      {
        "text": "[1 2 3 4 5 6] [1 2 3 4 5 6] [1 2 3 4 5 7]"
      },
      {
        "text": "[1 2 3 4 5] [1 2 3 4 5 6] [1 2 3 4 5]"
      }
    ]
  },
  {
    "topic_id": 2,
    "text": "Что выведет код?",
    "code": "a1 := make([]int, 0)\r\na1 = append(a1, []int{1, 2, 3, 4, 5}...)\r\nfmt.Println(len(a1), cap(a1))",
    "explanation": "capacity после append НЕ обязана быть равна len. \r\nlen увеличился корректно, а cap \u003e= len\r\n",
    "answers": [
      {
        "text": "5 5"
      },
      {
        "text": "5 6"
      },
      {
        "text": "6 6"
      },
      {
        "text": "Определяется runtime",
        "correct": true
      }
    ]
  },
  {
    "topic_id": 17,
    "text": "Что из перечисленного верно про string в Go?",
    "explanation": "В Go string — это immutable последовательность байт, обычно с UTF-8 содержимым",
    "answers": [
      {
        "text": "string — изменяемый тип"
      },
      {
        "text": "string хранит UTF-16"
      },
      {
        "text": "string — неизменяемая последовательность байт",
        "correct": true
      },
      {
        "text": "string всегда ASCII"
      }
    ]
  },
  {
    "topic_id": 17,
    "text": "Что вернёт len(\"привет\")?",
    "explanation": "Каждый кириллический символ занимает 2 байта в UTF-8 → 6 × 2 = 12.",
    "answers": [
      {
        "text": "6"
      },
      {
        "text": "12",
        "correct": true
      },
      {
        "text": "5"
      },
      {
        "text": "Ошибку компиляции"
      }
    ]
  },
  {
    "topic_id": 17,
    "text": "Что такое rune?",
    "explanation": "rune = int32, используется для представления Unicode-символов",
    "answers": [
      {
        "text": "Алиас для byte"
      },
      {
        "text": "Тип для UTF-16 символов"
      },
      {
        "text": "Алиас для int32, представляющий Unicode code point",
        "correct": true
      },
      {
        "text": "Тип для строк"
      }
    ]
  },
  {
    "topic_id": 17,
    "text": "Что делает range при обходе строки?",
    "explanation": "range декодирует UTF-8 и возвращает rune",
    "answers": [
      {
        "text": "Идёт по байтам"
      },
      {
        "text": "Идёт по runes (Unicode code points)",
        "correct": true
      },
      {
        "text": "Идёт по словам"
      },
      {
        "text": "Идёт по grapheme clusters"
      }
    ]
  },
  {
    "topic_id": 17,
    "text": "Что означает индекс i в for i, r := range s?",
    "explanation": "i — это байтовый индекс начала rune в строке",
    "answers": [
      {
        "text": "Номер символа"
      },
      {
        "text": "Номер rune"
      },
      {
        "text": "Смещение в байтах",
        "correct": true
      },
      {
        "text": "Всегда 0,1,2..."
      }
    ]
  },
  {
    "topic_id": 17,
    "text": "Почему s += \"a\" в цикле — плохая идея?",
    "explanation": "Строки неизменяемы, каждое += создаёт новую строку",
    "answers": [
      {
        "text": "Может привести к deadlock"
      },
      {
        "text": "Создаёт много аллокаций",
        "correct": true
      },
      {
        "text": "Работает только с ASCII"
      },
      {
        "text": "Не компилируется"
      }
    ]
  },
  {
    "topic_id": 17,
    "text": "Какой способ конкатенации строк наиболее эффективен?",
    "explanation": "strings.Builder минимизирует аллокации",
    "answers": [
      {
        "text": "s += part"
      },
      {
        "text": "fmt.Sprintf"
      },
      {
        "text": "strings.Builder",
        "correct": true
      },
      {
        "text": "[]rune"
      }
    ]
  },
  {
    "topic_id": 17,
    "text": "Что произойдёт при s[0] = 'H'?",
    "explanation": "string в Go — неизменяемый тип",
    "answers": [
      {
        "text": "Строка изменится"
      },
      {
        "text": "Panic во время выполнения"
      },
      {
        "text": "Ошибка компиляции",
        "correct": true
      },
      {
        "text": "Ничего"
      }
    ]
  },
  {
    "topic_id": 17,
    "text": "Почему s[:2] может быть опасным для UTF-8 строки?",
    "explanation": "Срез строки идёт по байтам, а не по rune",
    "answers": [
      {
        "text": "Может вызвать panic"
      },
      {
        "text": "Работает медленно"
      },
      {
        "text": "Может разрезать символ",
        "correct": true
      },
      {
        "text": "Всегда возвращает пустую строку"
      }
    ]
  },
  {
    "topic_id": 17,
    "text": "Может ли string быть nil?",
    "explanation": "string — value type, нулевое значение — пустая строка \"\"",
    "answers": [
      {
        "text": "Да"
      },
      {
        "text": "Нет",
        "correct": true
      },
      {
        "text": "Только через unsafe"
      },
      {
        "text": "Только в map"
      }
    ]
  },
  {
    "topic_id": 11,
    "text": "Что представляет собой error в Go?",
    "explanation": "error — это интерфейс. Любой тип с методом Error() string считается ошибкой.",
    "answers": [
      {
        "text": "Специальный тип, встроенный в рантайм"
      },
      {
        "text": "Структура стандартной библиотеки"
      },
      {
        "text": "Интерфейс с методом Error() string",
        "correct": true
      },
      {
        "text": "Исключение, как в Java"
      }
    ]
  },
  {
    "topic_id": 11,
    "text": "Зачем используется %w в fmt.Errorf?",
    "explanation": "%w оборачивает ошибку, позволяя использовать errors.Is и errors.As",
    "answers": [
      {
        "text": "Для форматирования строки"
      },
      {
        "text": "Для логирования ошибки"
      },
      {
        "text": "Для передачи ошибки вверх без потери контекста",
        "correct": true
      },
      {
        "text": "Для создания panic"
      }
    ]
  },
  {
    "topic_id": 11,
    "text": "Что вернёт errors.Is(err, target)?",
    "explanation": "errors.Is проходит по всей цепочке wrapping",
    "answers": [
      {
        "text": "true, если строки ошибок совпадают"
      },
      {
        "text": "true, если err == target"
      },
      {
        "text": "true, если target есть в цепочке wrapped-ошибок",
        "correct": true
      },
      {
        "text": "true только для стандартных ошибок"
      }
    ]
  },
  {
    "topic_id": 11,
    "text": "Когда стоит использовать errors.As?",
    "explanation": "errors.As ищет ошибку нужного типа в цепочке",
    "answers": [
      {
        "text": "Для сравнения двух ошибок"
      },
      {
        "text": "Для извлечения конкретного типа ошибки",
        "correct": true
      },
      {
        "text": "Для логирования"
      },
      {
        "text": "Для замены panic"
      }
    ]
  },
  {
    "topic_id": 11,
    "text": "Что такое sentinel error?",
    "explanation": "Обычно объявляется как var ErrX = errors.New(...)",
    "answers": [
      {
        "text": "Ошибка с кодом"
      },
      {
        "text": "Именованная ошибка, сравниваемая через errors.Is",
        "correct": true
      },
      {
        "text": "Panic-ошибка"
      },
      {
        "text": "Временная ошибка"
      }
    ]
  },
  {
    "topic_id": 11,
    "text": "Где НЕ рекомендуется логировать ошибки?",
    "explanation": "Сервис возвращает ошибку вверх, логирование — на границе приложения.",
    "answers": [
      {
        "text": "В HTTP handler"
      },
      {
        "text": "В gRPC interceptor"
      },
      {
        "text": "В service слое",
        "correct": true
      },
      {
        "text": "В main"
      }
    ]
  },
  {
    "topic_id": 11,
    "text": "Как правильно проверить ошибку, возвращённую из БД?",
    "explanation": "Только errors.Is корректно работает с wrapped-ошибками",
    "answers": [
      {
        "text": "if err == sql.ErrNoRows"
      },
      {
        "text": "if err.Error() == \"no rows\""
      },
      {
        "text": "if errors.Is(err, sql.ErrNoRows)",
        "correct": true
      },
      {
        "text": "if err != nil \u0026\u0026 err == nil"
      }
    ]
  },
  {
    "topic_id": 11,
    "text": "В каком случае оправдано использование panic?",
    "explanation": "panic — для программистских ошибок, не для ожидаемых ситуаций",
    "answers": [
      {
        "text": "Пользователь ввёл неверные данные"
      },
      {
        "text": "Ошибка в бизнес-логике"
      },
      {
        "text": "Невозможное состояние или баг",
        "correct": true
      },
      {
        "text": "Ошибка сети"
      }
    ]
  },
  {
    "topic_id": 11,
    "text": "Что произойдёт, если использовать fmt.Errorf(\"err: %v\", err) вместо %w?",
    "explanation": "Без %w цепочка wrapping теряется",
    "answers": [
      {
        "text": "Ошибка станет быстрее"
      },
      {
        "text": "Ошибка будет залогирована"
      },
      {
        "text": "Потеряется информация о причине ошибки",
        "correct": true
      },
      {
        "text": "Ничего не изменится"
      }
    ]
  },
  {
    "topic_id": 11,
    "text": "Какой подход лучше всего подходит для доменных ошибок в DDD?",
    "explanation": "Типизированные ошибки хорошо расширяются и легко анализируются через errors.As",
    "answers": [
      {
        "text": "Только panic"
      },
      {
        "text": "Строковые ошибки"
      },
      {
        "text": "Кастомные типы ошибок",
        "correct": true
      },
      {
        "text": "Игнорирование ошибок"
      }
    ]
  },
  {
    "topic_id": 14,
    "text": "Что выведет код?",
    "code": "func inc(x int) {\r\n    x++\r\n}\r\n\r\nfunc main() {\r\n    a := 5\r\n    inc(a)\r\n    fmt.Println(a)\r\n}",
    "explanation": "В Go аргументы передаются по значению. x — копия a, оригинал не меняется.",
    "answers": [
      {
        "text": "6"
      },
      {
        "text": "5",
        "correct": true
      },
      {
        "text": "panic"
      },
      {
        "text": "undefined"
      }
    ]
  },
  {
    "topic_id": 14,
    "text": "Что выведет код?",
    "code": "func inc(x *int) {\r\n    *x++\r\n}\r\n\r\nfunc main() {\r\n    a := 5\r\n    inc(\u0026a)\r\n    fmt.Println(a)\r\n}",
    "explanation": "Передан указатель, функция меняет значение по адресу a",
    "answers": [
      {
        "text": "5"
      },
      {
        "text": "6",
        "correct": true
      },
      {
        "text": "panic"
      },
      {
        "text": "не скомпилируется"
      }
    ]
  },
  {
    "topic_id": 14,
    "text": "Что произойдёт при выполнении?",
    "code": "func f(p *int) {\r\n    p = nil\r\n}\r\n\r\nfunc main() {\r\n    a := 10\r\n    p := \u0026a\r\n    f(p)\r\n    fmt.Println(*p)\r\n}",
    "explanation": "p передаётся по значению. Внутри f меняется только локальная копия указателя",
    "answers": [
      {
        "text": "panic"
      },
      {
        "text": "10",
        "correct": true
      },
      {
        "text": "nil"
      },
      {
        "text": "не скомпилируется"
      }
    ]
  },
  {
    "topic_id": 14,
    "text": "Что выведет код?",
    "code": "type User struct {\r\n    Name string\r\n}\r\n\r\nfunc rename(u User) {\r\n    u.Name = \"Bob\"\r\n}\r\n\r\nfunc main() {\r\n    user := User{Name: \"Alice\"}\r\n    rename(user)\r\n    fmt.Println(user.Name)\r\n}",
    "explanation": "Передана копия структуры, оригинал не изменился.",
    "answers": [
      {
        "text": "Bob"
      },
      {
        "text": "Alice",
        "correct": true
      },
      {
        "text": "panic"
      },
      {
        "text": "пустую строку"
      }
    ]
  },
  {
    "topic_id": 14,
    "text": "Что выведет код?",
    "code": "type User struct {\r\n    Name string\r\n}\r\n\r\nfunc rename(u *User) {\r\n    u.Name = \"Bob\"\r\n}\r\n\r\nfunc main() {\r\n    user := User{Name: \"Alice\"}\r\n    rename(\u0026user)\r\n    fmt.Println(user.Name)\r\n}",
    "explanation": "Передан указатель, изменение происходит над оригинальным объектом.",
    "answers": [
      {
        "text": "Alice"
      },
      {
        "text": "Bob",
        "correct": true
      },
      {
        "text": "panic"
      },
      {
        "text": "undefined"
      }
    ]
  },
  {
    "topic_id": 14,
    "text": "Что из этого верно для Go?",
    "explanation": "В Go всё передаётся по значению, включая указатели.",
    "answers": [
      {
        "text": "В Go есть передача по ссылке"
      },
      {
        "text": "В Go есть только передача по значению",
        "correct": true
      },
      {
        "text": "Указатели передаются по ссылке"
      },
      {
        "text": "Структуры всегда передаются по ссылке"
      }
    ]
  },
  {
    "topic_id": 14,
    "text": "Почему говорят “указатели ≠ ссылки” в Go?",
    "explanation": "Указатель — это обычное значение с адресом, без скрытой магии.",
    "answers": [
      {
        "text": "Потому что указатели нельзя разыменовывать"
      },
      {
        "text": "Потому что ссылки работают быстрее"
      },
      {
        "text": "Потому что указатель — явное значение, а ссылка — неявная абстракция",
        "correct": true
      },
      {
        "text": "Потому что ссылки устарели"
      }
    ]
  },
  {
    "topic_id": 14,
    "text": "Что передаётся в функцию при вызове f(\u0026x)?",
    "explanation": "Передаётся копия указателя, но он указывает на тот же адрес.",
    "answers": [
      {
        "text": "Сам объект x"
      },
      {
        "text": "Ссылка на x"
      },
      {
        "text": "Копия указателя на x",
        "correct": true
      },
      {
        "text": "Адрес функции f"
      }
    ]
  },
  {
    "topic_id": 14,
    "text": "Почему Go-дизайн с указателями важен для concurrency?",
    "explanation": "Явность владения данными упрощает reasoning в многопоточности",
    "answers": [
      {
        "text": "Потому что указатели потокобезопасны"
      },
      {
        "text": "Потому что убирает неявные изменения данных",
        "correct": true
      },
      {
        "text": "Потому что запрещает shared state"
      },
      {
        "text": "Потому что ускоряет GC"
      }
    ]
  },
  {
    "topic_id": 14,
    "text": "Когда использование указателя оправдано?",
    "explanation": "Указатели нужны по делу, а не «на всякий случай»",
    "answers": [
      {
        "text": "Всегда"
      },
      {
        "text": "Никогда"
      },
      {
        "text": "Когда нужно изменить объект или избежать копирования",
        "correct": true
      },
      {
        "text": "Только для примитивов"
      }
    ]
  },
  {
    "topic_id": 18,
    "text": "С какого релиза в Go появились Generics?",
    "explanation": "Generics официально добавлены в Go 1.18",
    "answers": [
      {
        "text": "Go 1.16"
      },
      {
        "text": "Go 1.17"
      },
      {
        "text": "Go 1.18",
        "correct": true
      },
      {
        "text": "Go 1.20"
      }
    ]
  },
  {
    "topic_id": 18,
    "text": "Что означает T any в сигнатуре функции?",
    "explanation": "any — это alias для interface{}",
    "answers": [
      {
        "text": "T — любой интерфейс"
      },
      {
        "text": "T — указатель"
      },
      {
        "text": "T — любой тип",
        "correct": true
      },
      {
        "text": "T — алиас struct{}"
      }
    ]
  },
  {
    "topic_id": 18,
    "text": "Чем Generics принципиально лучше interface{}?",
    "explanation": "Главное преимущество — типобезопасность на этапе",
    "answers": [
      {
        "text": "Быстрее на этапе выполнения"
      },
      {
        "text": "Проверка типов на compile-time",
        "correct": true
      },
      {
        "text": "Меньше кода"
      },
      {
        "text": "Работают с reflection"
      }
    ]
  },
  {
    "topic_id": 18,
    "text": "Можно ли использовать операторы (+, ==) с T any?",
    "explanation": "Без constraint компилятор не знает, какие операции разрешены.",
    "answers": [
      {
        "text": "Да, всегда"
      },
      {
        "text": "Да, если тип известен"
      },
      {
        "text": "Только через reflection"
      },
      {
        "text": "Нет, нужен constraint",
        "correct": true
      }
    ]
  },
  {
    "topic_id": 18,
    "text": "Заменяют ли Generics интерфейсы в Go?",
    "explanation": "Generics — про данные, интерфейсы — про поведение",
    "answers": [
      {
        "text": "Да"
      },
      {
        "text": "Частично"
      },
      {
        "text": "Только в структурах"
      },
      {
        "text": "Нет",
        "correct": true
      }
    ]
  },
  {
    "topic_id": 18,
    "text": "Скомпилируется ли код?",
    "code": "func Add[T any](a, b T) T {\r\n    return a + b\r\n}",
    "explanation": "any не гарантирует наличие оператора +",
    "answers": [
      {
        "text": "Да"
      },
      {
        "text": "Нет",
        "correct": true
      },
      {
        "text": "Зависит от T"
      },
      {
        "text": "Неопределенное поводение"
      }
    ]
  },
  {
    "topic_id": 18,
    "text": "Что не так с этим кодом?",
    "code": "type Box[T any] struct {\r\n    Value T\r\n}\r\n\r\nfunc (b Box[T]) Map[R any](f func(T) R) R {\r\n    return f(b.Value)\r\n}",
    "explanation": "В Go методы не могут объявлять свои generic-параметры",
    "answers": [
      {
        "text": "Ошибка синтаксиса"
      },
      {
        "text": "Нельзя использовать generics в методах"
      },
      {
        "text": "Метод не может иметь собственный тип-параметр",
        "correct": true
      },
      {
        "text": "Всё корректно"
      }
    ]
  },
  {
    "topic_id": 18,
    "text": "Скомпилируется ли вызов?",
    "code": "func Identity[T any](v T) T { return v }\r\n\r\nvar x any = 10\r\nIdentity(x)",
    "explanation": "Тип T выводится как any, а не int",
    "answers": [
      {
        "text": "Да, вернёт int"
      },
      {
        "text": "Да, вернёт any",
        "correct": true
      },
      {
        "text": "Нет"
      },
      {
        "text": "С panic"
      }
    ]
  },
  {
    "topic_id": 18,
    "text": "Скомпилируется ли код?",
    "code": "func Equal[T comparable](a, b T) bool {\r\n    return a == b\r\n}\r\n\r\nEqual([]int{1}, []int{1})",
    "explanation": "slice не comparable, даже если элементы comparable",
    "answers": [
      {
        "text": "Да"
      },
      {
        "text": "Нет",
        "correct": true
      },
      {
        "text": "Panic"
      },
      {
        "text": "Неопределенное поведение"
      }
    ]
  },
  {
    "topic_id": 18,
    "text": "Что выведет программа?",
    "code": "func Print[T any](v T) {\r\n\tfmt.Printf(\"%T\\n\", v)\r\n}\r\n\r\nPrint(10)\r\nPrint(\"hi\")",
    "explanation": "Generic подставляет конкретный тип, не стирая его",
    "answers": [
      {
        "text": "T и T"
      },
      {
        "text": "any и any"
      },
      {
        "text": "int и string",
        "correct": true
      },
      {
        "text": "Ошибка компиляции"
      }
    ]
  },
  {
    "topic_id": 11,
    "text": "Что выведет программа?",
    "code": "func main() {\r\n\tfmt.Println(\"Start\")\r\n\tsafe()\r\n\tfmt.Println(\"End\")\r\n}\r\nfunc safe() {\r\n\tdefer fmt.Println(\"Defer1\")\r\n\tdefer func() {\r\n\t\tif r := recover(); r != nil {\r\n\t\t\tfmt.Println(\"Recovered\")\r\n        }\r\n\t}()\r\n\tdefer fmt.Println(\"Defer2\")\r\n\tpanic(\"Boom\")\r\n}",
    "explanation": "Defer выполняются в обратном порядке.",
    "answers": [
      {
        "text": "Start Defer2 Recovered Defer1 End",
        "correct": true
      },
      {
        "text": "Start Defer1 Recovered Defer2 End"
      },
      {
        "text": "Start Recovered Defer2 Defer1 End"
      },
      {
        "text": "Start Recovered End"
      }
    ]
  },
  {
    "topic_id": 11,
    "text": "Будет ли программа падать?",
    "code": "func main() {\r\n\tgo worker()\r\n\tfmt.Println(\"main done\")\r\n}\r\n\r\nfunc worker() {\r\n\tdefer func() {\r\n\t\tif r := recover(); r != nil {\r\n\t\t\tfmt.Println(\"worker recovered:\", r)\r\n\t\t}\r\n\t}()\r\n\r\n\tpanic(\"goroutine panic\")\r\n}",
    "explanation": "main завершится, процесс остановится, вывод из worker может не появиться",
    "answers": [
      {
        "text": "Программа упадёт из-за panic"
      },
      {
        "text": "Panic будет пойман, но main завершит процесс",
        "correct": true
      },
      {
        "text": "Программа зависнет"
      },
      {
        "text": "Recover не сработает"
      }
    ]
  },
  {
    "topic_id": 11,
    "text": "Что выведет код?",
    "code": "defer fmt.Println(\"defer\")\r\ndefer func() {\r\n    fmt.Println(\"end\")\r\n    if err := recover(); err != nil {\r\n        fmt.Println(\"covered\")\r\n    }\r\n}()\r\nfmt.Println(\"start\")\r\npanic(\"panic\")",
    "explanation": "Паника отловлена, defer выполняются в обратном порядке.",
    "answers": [
      {
        "text": "start end covered defer",
        "correct": true
      },
      {
        "text": "start defer end covered"
      },
      {
        "text": "start defer covered end"
      },
      {
        "text": "start covered end defer"
      }
    ]
  },
  {
    "topic_id": 11,
    "text": "Что выведет код?",
    "code": "func tryRecover() {\r\n\tif err := recover(); err != nil {\r\n\t\tfmt.Println(\"covered\")\r\n\t}\r\n}\r\n\r\nfunc main() {\r\n\tdefer fmt.Println(\"defer\")\r\n\tdefer func() {\r\n\t\tfmt.Println(\"end\")\r\n\t\ttryRecover()\r\n\t}()\r\n\tfmt.Println(\"start\")\r\n\tpanic(\"panic\")\r\n}",
    "explanation": "recover() работает ТОЛЬКО если он вызван НЕПОСРЕДСТВЕННО внутри defer-функции",
    "answers": [
      {
        "text": "start end covered defer"
      },
      {
        "text": "start end defer",
        "correct": true
      },
      {
        "text": "start defer covered end"
      },
      {
        "text": "start covered end"
      }
    ]
  },
  {
    "topic_id": 4,
    "text": "Что выведет код?",
    "code": "m := map[string]int{\r\n\t\"a\": 1,\r\n\t\"b\": 2,\r\n\t\"c\": 3,\r\n}\r\n\r\nfor k, v := range m {\r\n\tif v%2 == 1 {\r\n\t\tdelete(m, k)\r\n\t}\r\n}\r\n\r\nfmt.Println(len(m))",
    "explanation": "Удаление элементов во время итерации разрешено и безопасно.\r\nУдаляются \"a\" и \"c\" (нечётные значения), остаётся только \"b\".",
    "answers": [
      {
        "text": "0"
      },
      {
        "text": "1",
        "correct": true
      },
      {
        "text": "2"
      },
      {
        "text": "panic"
      }
    ]
  },
  {
    "topic_id": 4,
    "text": "Что выведет код?",
    "code": "m := map[string]int{\r\n\t\"a\": 1,\r\n\t\"b\": 2,\r\n}\r\n\r\ncount := 0\r\nfor k := range m {\r\n\tcount++\r\n\tm[\"x\"+k] = 10\r\n}\r\n\r\nfmt.Println(count, len(m))",
    "explanation": "range гарантированно пройдёт только по элементам, существовавшим в начале итерации.\r\nНовые ключи (\"xa\", \"xb\") могут не быть пройдены, но они будут добавлены в map.",
    "answers": [
      {
        "text": "2 4",
        "correct": true
      },
      {
        "text": "4 4"
      },
      {
        "text": "2 2"
      },
      {
        "text": "panic"
      }
    ]
  },
  {
    "topic_id": 4,
    "text": "Что выведет код?",
    "code": "m := map[string]int{\r\n\t\"a\": 1,\r\n\t\"b\": 2,\r\n}\r\n\r\nfor k := range m {\r\n\tm[k] = m[k] * 10\r\n}\r\n\r\nfmt.Println(m[\"a\"], m[\"b\"])",
    "explanation": "Обновление значения существующего ключа во время range полностью безопасно и детерминировано.",
    "answers": [
      {
        "text": "1 2"
      },
      {
        "text": "10 20",
        "correct": true
      },
      {
        "text": "неопределено"
      },
      {
        "text": "panic"
      }
    ]
  },
  {
    "topic_id": 4,
    "text": "Что выведет код?",
    "code": "m := map[int]int{\r\n\t1: 1,\r\n\t2: 2,\r\n}\r\n\r\ngo func() {\r\n\tfor k := range m {\r\n\t\tfmt.Println(k)\r\n\t}\r\n}()\r\n\r\nm[3] = 3\r\ntime.Sleep(time.Second)\r\n",
    "explanation": "Одновременная итерация и запись в map из разных горутин →\r\nfatal error: concurrent map iteration and map write.\r\n\r\nКомпилятор это не ловит, ошибка возникает в рантайме.",
    "answers": [
      {
        "text": "всё нормально"
      },
      {
        "text": "может быть panic"
      },
      {
        "text": "всегда panic",
        "correct": true
      },
      {
        "text": "компилятор не позволит"
      }
    ]
  },
  {
    "topic_id": 4,
    "text": "Что выведет код?",
    "code": "m := map[string]int{\r\n\t\"a\": 1,\r\n\t\"b\": 2,\r\n}\r\n\r\nfor k := range m {\r\n\tif k == \"a\" {\r\n\t\tdelete(m, \"b\")\r\n\t}\r\n}\r\n\r\nfmt.Println(m)\r\n",
    "explanation": "Удалять любой ключ во время range разрешено, не только текущий.\r\nКлюч \"b\" будет удалён корректно, panic не будет.",
    "answers": [
      {
        "text": "map[a:1]",
        "correct": true
      },
      {
        "text": "map[a:1 b:2]"
      },
      {
        "text": "пустая map"
      },
      {
        "text": "panic"
      }
    ]
  },
  {
    "topic_id": 3,
    "text": "Что из перечисленного является корректным объявлением массива?",
    "explanation": "В Go сначала идёт длина в квадратных скобках, потом тип: [3]int.",
    "answers": [
      {
        "text": "var a []int{1,2,3}"
      },
      {
        "text": "a := [3]int{1,2,3}",
        "correct": true
      },
      {
        "text": "a := int[3]{1,2,3}"
      },
      {
        "text": "var a int[3]"
      }
    ]
  },
  {
    "topic_id": 3,
    "text": "Что произойдёт?",
    "code": "var a [3]int\r\nfmt.Println(a)",
    "explanation": "Массив инициализируется нулевыми значениями типа.",
    "answers": [
      {
        "text": "panic"
      },
      {
        "text": "[nil nil nil]"
      },
      {
        "text": "[0 0 0]",
        "correct": true
      },
      {
        "text": "Ошибка компиляции"
      }
    ]
  },
  {
    "topic_id": 3,
    "text": "Являются ли [3]int и [4]int одним типом?",
    "explanation": "Длина массива — часть типа.",
    "answers": [
      {
        "text": "Да"
      },
      {
        "text": "Нет",
        "correct": true
      },
      {
        "text": "Только при одинаковых значениях"
      },
      {
        "text": "Зависит от архитектуры"
      }
    ]
  },
  {
    "topic_id": 3,
    "text": "Что выведет код?",
    "code": "a := [3]int{1, 2, 3}\r\nb := a\r\nb[0] = 100\r\nfmt.Println(a)",
    "explanation": "Присваивание массива копирует его целиком.",
    "answers": [
      {
        "text": "[100 2 3]"
      },
      {
        "text": "[1 2 3]",
        "correct": true
      },
      {
        "text": "[0 2 3]"
      },
      {
        "text": "panic"
      }
    ]
  },
  {
    "topic_id": 3,
    "text": "Что произойдёт при передаче массива в функцию?",
    "code": "func f(a [3]int) {\r\n\ta[0] = 9\r\n}",
    "explanation": "Массив передаётся по значению (копируется).",
    "answers": [
      {
        "text": "Изменится оригинальный массив"
      },
      {
        "text": "Изменится только первый элемент"
      },
      {
        "text": "Изменения не выйдут наружу",
        "correct": true
      },
      {
        "text": "panic"
      }
    ]
  },
  {
    "topic_id": 3,
    "text": "Как правильно изменить массив внутри функции?",
    "explanation": "Указатель на массив позволяет изменить оригинал.",
    "answers": [
      {
        "text": "Передать []int"
      },
      {
        "text": "Передать *[3]int",
        "correct": true
      },
      {
        "text": "Использовать copy()"
      },
      {
        "text": "Это невозможно"
      }
    ]
  },
  {
    "topic_id": 3,
    "text": "Что выведет код?",
    "code": "a := [...]int{1, 2, 3, 4}\r\nfmt.Println(len(a))",
    "explanation": "... позволяет компилятору вывести длину массива.",
    "answers": [
      {
        "text": "3"
      },
      {
        "text": "4",
        "correct": true
      },
      {
        "text": "0"
      },
      {
        "text": "Ошибка компиляции"
      }
    ]
  },
  {
    "topic_id": 3,
    "text": "Что произойдёт?",
    "code": "a := [3]int{1, 2, 3}\r\nfmt.Println(a[3])",
    "explanation": "Проверка границ происходит во время выполнения.",
    "answers": [
      {
        "text": "Выведет 0"
      },
      {
        "text": "panic",
        "correct": true
      },
      {
        "text": "nil"
      },
      {
        "text": "Ошибка компиляции"
      }
    ]
  },
  {
    "topic_id": 3,
    "text": "Почему массивы редко используют напрямую в Go?",
    "explanation": "Фиксированный размер делает массивы неудобными — чаще используют срезы.",
    "answers": [
      {
        "text": "Они медленные"
      },
      {
        "text": "Их нельзя передавать в функции"
      },
      {
        "text": "У них фиксированный размер",
        "correct": true
      },
      {
        "text": "Они не поддерживаются стандартной библиотекой"
      }
    ]
  },
  {
    "topic_id": 10,
    "text": "Что произойдёт с этим кодом?",
    "code": "var mu sync.Mutex\r\n\r\nfunc main() {\r\n    mu.Lock()\r\n    mu.Lock()\r\n}",
    "explanation": "sync.Mutex не реентерабельный. Повторный Lock() в той же горутине приведёт к deadlock.",
    "answers": [
      {
        "text": "panic"
      },
      {
        "text": "программа зависнет",
        "correct": true
      },
      {
        "text": "второй Lock проигнорируется"
      },
      {
        "text": "компилятор не пропустит"
      }
    ]
  },
  {
    "topic_id": 10,
    "text": "Можно ли копировать sync.Mutex?",
    "explanation": "Mutex нельзя копировать вообще. Даже копирование до использования — потенциальная ошибка.",
    "answers": [
      {
        "text": "Да, всегда"
      },
      {
        "text": "Только до первого Lock()"
      },
      {
        "text": "Нет",
        "correct": true
      },
      {
        "text": "Только в struct без методов"
      }
    ]
  },
  {
    "topic_id": 10,
    "text": "Что гарантирует sync.WaitGroup?",
    "explanation": "WaitGroup только ждёт, но не синхронизирует доступ к данным.",
    "answers": [
      {
        "text": "Порядок выполнения горутин"
      },
      {
        "text": "Ограничение количества горутин"
      },
      {
        "text": "Ожидание завершения горутин",
        "correct": true
      },
      {
        "text": "Безопасный доступ к данным"
      }
    ]
  },
  {
    "topic_id": 10,
    "text": "Где ошибка?",
    "code": "var wg sync.WaitGroup\r\n\r\nfor i := 0; i \u003c 5; i++ {\r\n    go func() {\r\n        wg.Add(1)\r\n        defer wg.Done()\r\n        fmt.Println(i)\r\n    }()\r\n}\r\n\r\nwg.Wait()",
    "explanation": "Add() нельзя вызывать внутри горутины",
    "answers": [
      {
        "text": "Нет ошибки"
      },
      {
        "text": "Add должен быть до запуска горутины",
        "correct": true
      },
      {
        "text": "i передаётся неправильно"
      },
      {
        "text": "Всё выше перечисленное"
      }
    ]
  },
  {
    "topic_id": 10,
    "text": "Что делает RWMutex?",
    "explanation": "Чтения параллельны, запись эксклюзивна.",
    "answers": [
      {
        "text": "Несколько писателей"
      },
      {
        "text": "Один читатель"
      },
      {
        "text": "Несколько читателей или один писатель",
        "correct": true
      },
      {
        "text": "Работает как Mutex"
      }
    ]
  },
  {
    "topic_id": 10,
    "text": "Можно ли апгрейдить RLock() в Lock()?",
    "code": "mu.RLock()\r\nmu.Lock()",
    "explanation": "Это гарантированный deadlock.\r\nRWMutex не поддерживает апгрейд блокировок.",
    "answers": [
      {
        "text": "Да"
      },
      {
        "text": "Нет",
        "correct": true
      },
      {
        "text": "Да, если нет других читателей"
      },
      {
        "text": "Зависит от версии Go"
      }
    ]
  },
  {
    "topic_id": 10,
    "text": "Что делает sync.Once?",
    "explanation": "Once гарантирует однократное выполнение, даже при конкурентных вызовах.",
    "answers": [
      {
        "text": "Выполняет функцию один раз на горутину"
      },
      {
        "text": "Выполняет функцию ровно один раз за всё время",
        "correct": true
      },
      {
        "text": "Блокирует другие горутины"
      },
      {
        "text": "Работает как mutex"
      }
    ]
  },
  {
    "topic_id": 10,
    "text": "Что произойдёт?",
    "code": "ch := make(chan int)\r\n\r\ngo func() {\r\n    ch \u003c- 1\r\n}()\r\n\r\ntime.Sleep(time.Second)",
    "explanation": "Нет получателя → горутина заблокируется навсегда.",
    "answers": [
      {
        "text": "panic"
      },
      {
        "text": "программа завершится"
      },
      {
        "text": "утечка горутины",
        "correct": true
      },
      {
        "text": "значение отправится"
      }
    ]
  },
  {
    "topic_id": 10,
    "text": "Когда лучше использовать atomic, а не Mutex?",
    "explanation": "atomic подходит только для простых операций над примитивами.",
    "answers": [
      {
        "text": "Для сложных структур"
      },
      {
        "text": "Для инкремента счётчиков",
        "correct": true
      },
      {
        "text": "Для map"
      },
      {
        "text": "Всегда быстрее"
      }
    ]
  },
  {
    "topic_id": 10,
    "text": "Что из этого НЕ является средством синхронизации?",
    "explanation": "context управляет жизненным циклом, но не защищает данные.",
    "answers": [
      {
        "text": "Mutex"
      },
      {
        "text": "WaitGroup"
      },
      {
        "text": "context.Context",
        "correct": true
      },
      {
        "text": "chan"
      }
    ]
  },
  {
    "topic_id": 19,
    "text": "Что делает select, если готовы несколько case?",
    "explanation": "Спецификация Go гарантирует случайный выбор между готовыми ветками, чтобы избежать starvation.",
    "answers": [
      {
        "text": "Выполняет первый по порядку"
      },
      {
        "text": "Выбирает случайный case",
        "correct": true
      },
      {
        "text": "Выполняет все готовые case"
      },
      {
        "text": "Вызывает панику"
      }
    ]
  },
  {
    "topic_id": 19,
    "text": "Что произойдёт, если select не содержит default и все каналы заблокированы?",
    "explanation": "select ждёт, пока хотя бы один case станет готов.",
    "answers": [
      {
        "text": "Программа завершится"
      },
      {
        "text": "select заблокируется",
        "correct": true
      },
      {
        "text": "Будет выполнен нулевой case"
      },
      {
        "text": "Произойдёт deadlock на уровне компиляции"
      }
    ]
  },
  {
    "topic_id": 19,
    "text": "Что делает default в select?",
    "explanation": "С default select становится неблокирующим.",
    "answers": [
      {
        "text": "Выполняется только при таймауте"
      },
      {
        "text": "Выполняется всегда последним"
      },
      {
        "text": "Выполняется, если ни один case не готов",
        "correct": true
      },
      {
        "text": "Запрещает блокировку каналов"
      }
    ]
  },
  {
    "topic_id": 19,
    "text": "Что выведет код?",
    "code": "ch := make(chan int)\r\nclose(ch)\r\n\r\nselect {\r\ncase v := \u003c-ch:\r\n    fmt.Println(v)\r\n}",
    "explanation": "Чтение из закрытого канала не блокируется и возвращает zero-value.",
    "answers": [
      {
        "text": "Паника"
      },
      {
        "text": "Ничего"
      },
      {
        "text": "0",
        "correct": true
      },
      {
        "text": "Deadlock"
      }
    ]
  },
  {
    "topic_id": 19,
    "text": "Зачем чаще всего добавляют ctx.Done() в select?",
    "explanation": "Это стандартный способ остановить горутину, когда она больше не нужна.",
    "answers": [
      {
        "text": "Для ускорения работы"
      },
      {
        "text": "Для логирования"
      },
      {
        "text": "Для отмены и корректного завершения горутины",
        "correct": true
      },
      {
        "text": "Для предотвращения гонок данных"
      }
    ]
  },
  {
    "topic_id": 19,
    "text": "Что делает такой код?",
    "explanation": "Нет case → нет возможности продолжить выполнение.",
    "answers": [
      {
        "text": "Вызывает panic"
      },
      {
        "text": "Блокируется навсегда",
        "correct": true
      },
      {
        "text": "Ожидает первый готовый канал"
      },
      {
        "text": "Работает как sleep(0)"
      }
    ]
  },
  {
    "topic_id": 19,
    "text": "Что плохого в этом коде?",
    "code": "for {\r\n    select {\r\n    case v := \u003c-ch:\r\n        fmt.Println(v)\r\n    default:\r\n    }\r\n}",
    "explanation": "default выполняется мгновенно → цикл крутится без пауз.",
    "answers": [
      {
        "text": "Он не компилируется"
      },
      {
        "text": "Он может паниковать"
      },
      {
        "text": "Он создаёт busy loop и жрёт CPU",
        "correct": true
      },
      {
        "text": "Он теряет данные"
      }
    ]
  },
  {
    "topic_id": 19,
    "text": "Можно ли использовать select с одним case?",
    "explanation": "select { case \u003c-ch: } эквивалентен \u003c-ch.",
    "answers": [
      {
        "text": "Нет, это ошибка компиляции"
      },
      {
        "text": "Да, но это бессмысленно",
        "correct": true
      },
      {
        "text": "Да, и это ускоряет код"
      },
      {
        "text": "Да, и это обязательно"
      }
    ]
  },
  {
    "topic_id": 19,
    "text": "Что произойдёт, если отправка в канал в select заблокирована?",
    "explanation": "select выбирает любой готовый case, блокированные игнорируются.",
    "answers": [
      {
        "text": "Будет выполнен другой готовый case",
        "correct": true
      },
      {
        "text": "Будет panic"
      },
      {
        "text": "Канал автоматически расширится"
      },
      {
        "text": "Отправка произойдёт позже без блокировки"
      }
    ]
  },
  {
    "topic_id": 19,
    "text": "Почему этот код безопаснее, чем просто ch \u003c- v?",
    "code": "select {\r\ncase ch \u003c- v:\r\ncase \u003c-ctx.Done():\r\n    return\r\n}",
    "explanation": "Если получатель ушёл — ctx.Done() спасает горутину от утечки.",
    "answers": [
      {
        "text": "Потому что быстрее"
      },
      {
        "text": "Потому что не использует mutex"
      },
      {
        "text": "Потому что защищает от вечной блокировки",
        "correct": true
      },
      {
        "text": "Потому что канал буферизирован"
      }
    ]
  },
  {
    "topic_id": 6,
    "text": "Что такое интерфейс в Go?",
    "explanation": "Интерфейс в Go описывает только поведение — набор методов, без данных.",
    "answers": [
      {
        "text": "Структура с виртуальными методами"
      },
      {
        "text": "Контейнер для данных и методов"
      },
      {
        "text": "Набор сигнатур методов",
        "correct": true
      },
      {
        "text": "Способ наследования структур"
      }
    ]
  },
  {
    "topic_id": 6,
    "text": "Как тип в Go реализует интерфейс?",
    "explanation": "Реализация интерфейса в Go всегда неявная.",
    "answers": [
      {
        "text": "Через ключевое слово implements"
      },
      {
        "text": "Через embedding интерфейса"
      },
      {
        "text": "Неявно, если реализует все методы",
        "correct": true
      },
      {
        "text": "Через наследование"
      }
    ]
  },
  {
    "topic_id": 6,
    "text": "Что выведет код?",
    "code": "var p *MyError = nil\r\nvar err error = p\r\nfmt.Println(err == nil)",
    "explanation": "Интерфейс содержит тип (*MyError) и значение (nil), поэтому он не равен nil.",
    "answers": [
      {
        "text": "true"
      },
      {
        "text": "false",
        "correct": true
      },
      {
        "text": "panic"
      },
      {
        "text": "Не скомпилируется"
      }
    ]
  },
  {
    "topic_id": 6,
    "text": "Когда интерфейс в Go считается nil?",
    "explanation": "Интерфейс — это пара (type, value)",
    "answers": [
      {
        "text": "Когда значение внутри равно nil"
      },
      {
        "text": "Когда тип внутри равен nil"
      },
      {
        "text": "Когда тип и значение равны nil",
        "correct": true
      },
      {
        "text": "Всегда, если присвоен nil"
      }
    ]
  },
  {
    "topic_id": 6,
    "text": "Что означает var v any?",
    "explanation": "any — алиас для interface{}",
    "answers": [
      {
        "text": "v может быть только ссылочным типом"
      },
      {
        "text": "v — это пустой интерфейс",
        "correct": true
      },
      {
        "text": "v — это generic тип"
      },
      {
        "text": "v — это unsafe тип"
      }
    ]
  },
  {
    "topic_id": 6,
    "text": "Как безопасно получить конкретный тип из интерфейса?",
    "explanation": "Вариант с ok предотвращает panic",
    "answers": [
      {
        "text": "v.(T)"
      },
      {
        "text": "T(v)"
      },
      {
        "text": "v as T"
      },
      {
        "text": "v.(T), ok",
        "correct": true
      }
    ]
  },
  {
    "topic_id": 6,
    "text": "Почему в Go принято делать маленькие интерфейсы?",
    "explanation": "Маленькие интерфейсы легче реализовывать и мокать",
    "answers": [
      {
        "text": "Так быстрее компилируется код"
      },
      {
        "text": "Это ограничение языка"
      },
      {
        "text": "Это упрощает реализацию и тестирование",
        "correct": true
      },
      {
        "text": "Большие интерфейсы запрещены"
      }
    ]
  },
  {
    "topic_id": 6,
    "text": "Что значит принцип “Accept interfaces, return structs”?",
    "explanation": "Это повышает гибкость API и избегает потери конкретного типа",
    "answers": [
      {
        "text": "Всегда возвращать интерфейсы"
      },
      {
        "text": "Всегда принимать структуры"
      },
      {
        "text": "Принимать интерфейсы, возвращать конкретные типы",
        "correct": true
      },
      {
        "text": "Использовать generics вместо интерфейсов"
      }
    ]
  },
  {
    "topic_id": 6,
    "text": "Когда интерфейсы подходят лучше, чем generics?",
    "explanation": "Интерфейсы нужны, когда важна разная реализация поведения.",
    "answers": [
      {
        "text": "Для алгоритмов сортировки"
      },
      {
        "text": "Для хранения данных"
      },
      {
        "text": "Для полиморфного поведения",
        "correct": true
      },
      {
        "text": "Для математических вычислений"
      }
    ]
  },
  {
    "topic_id": 6,
    "text": "Какая из практик считается плохой?",
    "explanation": "Интерфейсы должны появляться из реальных потребностей, а не “про запас”.",
    "answers": [
      {
        "text": "Объявлять интерфейсы рядом с кодом использования"
      },
      {
        "text": "Использовать интерфейсы для внешних границ системы"
      },
      {
        "text": "Делать интерфейсы «на будущее» без реальных реализаций",
        "correct": true
      },
      {
        "text": "Использовать интерфейсы для моков в тестах"
      }
    ]
  },
  {
    "topic_id": 5,
    "text": "Что выведет код?",
    "code": "func main() {\r\n\tfmt.Println(sum(2, 3))\r\n}\r\n\r\nfunc sum(a, b int) (result int) {\r\n\tresult = a + b\r\n\treturn\r\n}",
    "explanation": "result — именованное возвращаемое значение. Оно присваивается и возвращается неявно.",
    "answers": [
      {
        "text": "0"
      },
      {
        "text": "5",
        "correct": true
      },
      {
        "text": "panic"
      },
      {
        "text": "ошибка компиляции"
      }
    ]
  },
  {
    "topic_id": 5,
    "text": "2️⃣ Когда выполняется defer?",
    "explanation": "defer выполняется после вычисления return, но до выхода из функции.",
    "answers": [
      {
        "text": "Сразу после объявления"
      },
      {
        "text": "Перед return"
      },
      {
        "text": "После return, но до выхода из функции",
        "correct": true
      },
      {
        "text": "В отдельной горутине"
      }
    ]
  },
  {
    "topic_id": 5,
    "text": "Что выведет код?",
    "code": "func main() {\r\n\tdefer fmt.Println(calc())\r\n\tfmt.Println(\"end\")\r\n}\r\n\r\nfunc calc() int {\r\n\treturn 42\r\n}",
    "explanation": "Аргументы defer вычисляются сразу, но выполняется он позже.",
    "answers": [
      {
        "text": "end → 42",
        "correct": true
      },
      {
        "text": "42 → end"
      },
      {
        "text": "end"
      },
      {
        "text": "panic"
      }
    ]
  },
  {
    "topic_id": 5,
    "text": "Какое объявление variadic-функции корректно?",
    "explanation": "...int — переменное число аргументов типа int.",
    "answers": [
      {
        "text": "func f(...int) int"
      },
      {
        "text": "func f(nums ...int) int",
        "correct": true
      },
      {
        "text": "func f(nums []int...) int"
      },
      {
        "text": "func f(nums ...[]int) int"
      }
    ]
  },
  {
    "topic_id": 5,
    "text": "Что произойдёт?",
    "code": "func main() {\r\n\tf := func() {\r\n\t\tfmt.Println(\"hi\")\r\n\t}\r\n\tf()\r\n}",
    "explanation": "Анонимная функция — обычное значение, её можно вызвать.",
    "answers": [
      {
        "text": "panic"
      },
      {
        "text": "ошибка компиляции"
      },
      {
        "text": "ничего не выведет"
      },
      {
        "text": "hi",
        "correct": true
      }
    ]
  },
  {
    "topic_id": 5,
    "text": "Что выведет код?",
    "code": "func main() {\r\n\tx := 10\r\n\tchange(x)\r\n\tfmt.Println(x)\r\n}\r\n\r\nfunc change(x int) {\r\n\tx = 20\r\n}",
    "explanation": "Аргументы передаются по значению.",
    "answers": [
      {
        "text": "10",
        "correct": true
      },
      {
        "text": "20"
      },
      {
        "text": "panic"
      },
      {
        "text": "ошибка компиляции"
      }
    ]
  },
  {
    "topic_id": 5,
    "text": "Что выведет код?",
    "code": "func main() {\r\n\tfmt.Println(test())\r\n}\r\n\r\nfunc test() (x int) {\r\n\tdefer func() {\r\n\t\tx = 10\r\n\t}()\r\n\treturn 5\r\n}",
    "explanation": "defer изменяет именованное возвращаемое значение перед выходом из функции.",
    "answers": [
      {
        "text": "5"
      },
      {
        "text": "10",
        "correct": true
      },
      {
        "text": "0"
      },
      {
        "text": "panic"
      }
    ]
  },
  {
    "topic_id": 5,
    "text": "Где корректно использовать recover?  A)",
    "explanation": "recover работает только внутри defer.",
    "answers": [
      {
        "text": "В любой функции"
      },
      {
        "text": "В main"
      },
      {
        "text": "Только внутри defer",
        "correct": true
      },
      {
        "text": "В отдельной горутине"
      }
    ]
  },
  {
    "topic_id": 5,
    "text": "Как правильно передавать context.Context?",
    "explanation": "Это официальная конвенция Go.",
    "answers": [
      {
        "text": "Хранить в структуре"
      },
      {
        "text": "Передавать последним аргументом"
      },
      {
        "text": "Передавать первым аргументом",
        "correct": true
      },
      {
        "text": "Можно передавать nil"
      }
    ]
  },
  {
    "topic_id": 5,
    "text": "Что выведет код?",
    "code": "func main() {\r\n\tfunc() {\r\n\t\tfmt.Println(\"A\")\r\n\t}()\r\n\tfmt.Println(\"B\")\r\n}",
    "explanation": "Анонимная функция вызывается сразу.",
    "answers": [
      {
        "text": "B → A"
      },
      {
        "text": "A → B",
        "correct": true
      },
      {
        "text": "только B"
      },
      {
        "text": "panic"
      }
    ]
  },
  {
    "topic_id": 7,
    "text": "Что происходит, когда main завершает выполнение?",
    "explanation": "main — обычная горутина. Когда она заканчивается, процесс Go завершается целиком.",
    "answers": [
      {
        "text": "Программа ждёт завершения всех горутин"
      },
      {
        "text": "Завершается только goroutine main"
      },
      {
        "text": "Завершается весь процесс, все горутины уничтожаются",
        "correct": true
      },
      {
        "text": "Зависит от количества CPU"
      }
    ]
  },
  {
    "topic_id": 7,
    "text": "Что делает ключевое слово go?",
    "explanation": "Go сам решает, будет ли выполнение параллельным или конкурентным.",
    "answers": [
      {
        "text": "Создаёт новый поток ОС"
      },
      {
        "text": "Запускает функцию асинхронно в новой горутине",
        "correct": true
      },
      {
        "text": "Ставит функцию в очередь планировщика ОС"
      },
      {
        "text": "Гарантирует параллельное выполнение"
      }
    ]
  },
  {
    "topic_id": 7,
    "text": "Можно ли остановить горутину извне?",
    "explanation": "Горутины нельзя убить принудительно — только кооперативная отмена.",
    "answers": [
      {
        "text": "Да, через runtime.StopGoroutine"
      },
      {
        "text": "Да, через context.CancelFunc",
        "correct": true
      },
      {
        "text": "Нет, только она сама может завершиться"
      },
      {
        "text": "Да, если вызвать panic"
      }
    ]
  },
  {
    "topic_id": 7,
    "text": "Что выведет код?",
    "code": "for i := 0; i \u003c 3; i++ {\r\n\tgo func() {\r\n\t\tfmt.Print(i)\r\n\t}()\r\n}\r\ntime.Sleep(time.Second)",
    "explanation": "Все горутины захватывают одну и ту же переменную i",
    "answers": [
      {
        "text": "012"
      },
      {
        "text": "123"
      },
      {
        "text": "222"
      },
      {
        "text": "Неопределённый вывод",
        "correct": true
      }
    ]
  },
  {
    "topic_id": 7,
    "text": "Какой минимальный размер стека у горутины?",
    "explanation": "Стек горутины маленький и растёт динамически.",
    "answers": [
      {
        "text": "~8 MB"
      },
      {
        "text": "~1 MB"
      },
      {
        "text": "~64 KB"
      },
      {
        "text": "~2 KB",
        "correct": true
      }
    ]
  },
  {
    "topic_id": 7,
    "text": "Что произойдёт?",
    "code": "go func() {\r\n\tpanic(\"boom\")\r\n}()\r\ntime.Sleep(time.Second)",
    "explanation": "Непойманная паника в любой горутине завершает весь процесс.",
    "answers": [
      {
        "text": "Паника убьёт только эту горутину"
      },
      {
        "text": "Паника будет проигнорирована"
      },
      {
        "text": "Программа завершится",
        "correct": true
      },
      {
        "text": "Поведение зависит от версии Go"
      }
    ]
  },
  {
    "topic_id": 7,
    "text": "Что делает WaitGroup?",
    "explanation": "Это механизм синхронизации, а не управления жизненным циклом.",
    "answers": [
      {
        "text": "Останавливает горутины"
      },
      {
        "text": "Ждёт завершения набора горутин",
        "correct": true
      },
      {
        "text": "Передаёт данные между горутинами"
      },
      {
        "text": "Отменяет выполнение"
      }
    ]
  },
  {
    "topic_id": 7,
    "text": "Что случится, если горутина пишет в канал, а читателя нет?",
    "explanation": "Отправка в небуферизированный канал — блокирующая операция.",
    "answers": [
      {
        "text": "Значение теряется"
      },
      {
        "text": "Канал автоматически закрывается"
      },
      {
        "text": "Горутина блокируется",
        "correct": true
      },
      {
        "text": "Go выбросит ошибку компиляции"
      }
    ]
  },
  {
    "topic_id": 7,
    "text": "Что гарантирует select?",
    "explanation": "Если готово несколько — выбор псевдослучайный.",
    "answers": [
      {
        "text": "Выполнение всех case"
      },
      {
        "text": "Выбор первого по порядку case"
      },
      {
        "text": "Выбор одного готового case",
        "correct": true
      },
      {
        "text": "Справедливое выполнение горутин"
      }
    ]
  },
  {
    "topic_id": 7,
    "text": "Как правильно передать значение переменной цикла в горутину?",
    "explanation": "Это создаёт отдельную копию значения.",
    "answers": [
      {
        "text": "Использовать sync.Mutex"
      },
      {
        "text": "Передать переменную параметром функции",
        "correct": true
      },
      {
        "text": "Объявить переменную global"
      },
      {
        "text": "Использовать atomic"
      }
    ]
  },
  {
    "topic_id": 21,
    "text": "Что такое Continuous Integration (CI)?",
    "explanation": "CI — это частые коммиты + автоматический build/test/lint.",
    "answers": [
      {
        "text": "Автоматическое выкатывание кода в продакшен"
      },
      {
        "text": "Регулярное слияние кода с автоматическими проверками",
        "correct": true
      },
      {
        "text": "Непрерывная доставка фич пользователям"
      },
      {
        "text": "Ручная сборка и тестирование перед релизом"
      }
    ]
  },
  {
    "topic_id": 21,
    "text": "В чём отличие Continuous Delivery от Continuous Deployment?",
    "explanation": "Delivery — «готово к релизу», Deployment — «в прод без кнопки».",
    "answers": [
      {
        "text": "Delivery всегда автоматически выкатывает код"
      },
      {
        "text": "Deployment требует ручного подтверждения"
      },
      {
        "text": "Delivery подготавливает релиз, Deployment выкатывает автоматически",
        "correct": true
      },
      {
        "text": "Между ними нет разницы"
      }
    ]
  },
  {
    "topic_id": 21,
    "text": "Зачем запускать go test -race в CI?",
    "explanation": "Race detector находит конкурентные баги, но замедляет тесты.",
    "answers": [
      {
        "text": "Для ускорения тестов"
      },
      {
        "text": "Для поиска гонок данных",
        "correct": true
      },
      {
        "text": "Для уменьшения потребления памяти"
      },
      {
        "text": "Для логирования ошибок"
      }
    ]
  },
  {
    "topic_id": 21,
    "text": "Где правильно хранить секреты для CI/CD?",
    "explanation": "Секреты не должны попадать в git.",
    "answers": [
      {
        "text": "В .env файле в репозитории"
      },
      {
        "text": "В коде приложения"
      },
      {
        "text": "В секретах CI (Secrets / Variables)",
        "correct": true
      },
      {
        "text": "В README проекта"
      }
    ]
  },
  {
    "topic_id": 21,
    "text": "Что происходит, если шаг CI упал?",
    "explanation": "CI — это gate, дальше идти нельзя.",
    "answers": [
      {
        "text": "CD всё равно выполнится"
      },
      {
        "text": "Пайплайн останавливается",
        "correct": true
      },
      {
        "text": "Код автоматически откатывается"
      },
      {
        "text": "Ошибка игнорируется"
      }
    ]
  },
  {
    "topic_id": 21,
    "text": "Зачем линтеры в CI?",
    "explanation": "Линтеры ловят проблемы до рантайма.",
    "answers": [
      {
        "text": "Для ускорения работы приложения"
      },
      {
        "text": "Для форматирования HTML"
      },
      {
        "text": "Для поиска потенциальных багов и плохих практик",
        "correct": true
      },
      {
        "text": "Только для красоты"
      }
    ]
  },
  {
    "topic_id": 21,
    "text": "Что такое rollback в CD?",
    "explanation": "Rollback — ключ к безопасным релизам.",
    "answers": [
      {
        "text": "Пересборка Docker-образа"
      },
      {
        "text": "Возврат к предыдущей стабильной версии",
        "correct": true
      },
      {
        "text": "Очистка базы данных"
      },
      {
        "text": "Перезапуск CI"
      }
    ]
  },
  {
    "topic_id": 21,
    "text": "Зачем использовать Docker в CI/CD?",
    "explanation": "«Работает у меня» перестаёт быть проблемой.",
    "answers": [
      {
        "text": "Только для локальной разработки"
      },
      {
        "text": "Для одинаковой среды на всех этапах",
        "correct": true
      },
      {
        "text": "Чтобы писать меньше кода"
      },
      {
        "text": "Для ускорения сети"
      }
    ]
  },
  {
    "topic_id": 21,
    "text": "Что такое blue-green deployment?",
    "explanation": "Быстро, безопасно, с мгновенным rollback.",
    "answers": [
      {
        "text": "Параллельная обработка запросов"
      },
      {
        "text": "Два прод-окружения с переключением трафика",
        "correct": true
      },
      {
        "text": "Тестирование только ветки main"
      },
      {
        "text": "Локальный деплой"
      }
    ]
  },
  {
    "topic_id": 21,
    "text": "Зачем Go-приложению graceful shutdown при деплое?",
    "explanation": "Особенно важно для HTTP/gRPC сервисов.",
    "answers": [
      {
        "text": "Чтобы быстрее завершить процесс"
      },
      {
        "text": "Чтобы не потерять активные запросы и горутины",
        "correct": true
      },
      {
        "text": "Чтобы уменьшить бинарник"
      },
      {
        "text": "Чтобы прошёл линтер"
      }
    ]
  },
  {
    "topic_id": 20,
    "text": "Какой файл будет автоматически найден go test?",
    "explanation": "Go ищет только файлы с суффиксом *_test.go.",
    "answers": [
      {
        "text": "test_math.go"
      },
      {
        "text": "math.test.go"
      },
      {
        "text": "math_test.go",
        "correct": true
      },
      {
        "text": "math_testing.go"
      }
    ]
  },
  {
    "topic_id": 20,
    "text": "В чём разница между t.Fatal и t.Error?",
    "explanation": "t.Fatal вызывает runtime.Goexit() → тест сразу прекращается.",
    "answers": [
      {
        "text": "Разницы нет"
      },
      {
        "text": "t.Fatal завершает все тесты"
      },
      {
        "text": "t.Fatal завершает текущий тест немедленно",
        "correct": true
      },
      {
        "text": "t.Error не помечает тест как failed"
      }
    ]
  },
  {
    "topic_id": 20,
    "text": "Что делает t.Parallel()?",
    "explanation": "Планировщик Go решает, какие параллельные тесты выполнять одновременно.",
    "answers": [
      {
        "text": "Запускает тест в отдельной ОС-нити"
      },
      {
        "text": "Тест может выполняться параллельно с другими тестами",
        "correct": true
      },
      {
        "text": "Все subtests всегда запускаются параллельно"
      },
      {
        "text": "Тест выполняется быстрее"
      }
    ]
  },
  {
    "topic_id": 20,
    "text": "Почему этот код был проблемным до Go 1.22?",
    "code": "for _, tt := range tests {\r\n    t.Run(tt.name, func(t *testing.T) {\r\n        t.Parallel()\r\n        check(tt)\r\n    })\r\n}",
    "explanation": "До Go 1.22 переменная цикла была общей для всех итераций.",
    "answers": [
      {
        "text": "t.Run нельзя использовать в цикле"
      },
      {
        "text": "Переменная tt захватывалась некорректно",
        "correct": true
      },
      {
        "text": "t.Parallel запрещён в subtests"
      },
      {
        "text": "check вызывается конкурентно"
      }
    ]
  },
  {
    "topic_id": 20,
    "text": "Как правильно проверять конкретную ошибку?",
    "explanation": "errors.Is корректно работает с wrapped-ошибками.",
    "answers": [
      {
        "text": "if err != nil { t.Fatal(err) }"
      },
      {
        "text": "if err == ErrNotFound { t.Fatal(\"error\") }"
      },
      {
        "text": "if !errors.Is(err, ErrNotFound) { t.Fatalf(\"expected ErrNotFound, got %v\", err) }",
        "correct": true
      },
      {
        "text": "t.Fatal(err)"
      }
    ]
  },
  {
    "topic_id": 20,
    "text": "Зачем использовать package foo_test?",
    "explanation": "Проверяется только публичный API пакета.",
    "answers": [
      {
        "text": "Для ускорения тестов"
      },
      {
        "text": "Для доступа к приватным полям"
      },
      {
        "text": "Для black-box тестирования",
        "correct": true
      },
      {
        "text": "Чтобы go test работал корректно"
      }
    ]
  },
  {
    "topic_id": 20,
    "text": "Зачем нужен TestMain?",
    "explanation": "Используется для инициализации ресурсов (БД, env, контейнеры).",
    "answers": [
      {
        "text": "Чтобы заменить main()"
      },
      {
        "text": "Чтобы управлять порядком тестов"
      },
      {
        "text": "Чтобы сделать setup / teardown",
        "correct": true
      },
      {
        "text": "Чтобы запускать subtests"
      }
    ]
  },
  {
    "topic_id": 20,
    "text": "Какой флаг включает race detector?",
    "explanation": "Находит data race во время выполнения тестов.",
    "answers": [
      {
        "text": "-parallel"
      },
      {
        "text": "-count=1"
      },
      {
        "text": "-race",
        "correct": true
      },
      {
        "text": "-bench"
      }
    ]
  },
  {
    "topic_id": 20,
    "text": "Почему в Go часто пишут mock’и вручную?",
    "explanation": "Интерфейсы + явная реализация = читаемый код.",
    "answers": [
      {
        "text": "Нет библиотек"
      },
      {
        "text": "Генераторы запрещены"
      },
      {
        "text": "Проще, типобезопасно, без магии",
        "correct": true
      },
      {
        "text": "Так исторически сложилось"
      }
    ]
  },
  {
    "topic_id": 20,
    "text": "Что плохо делать в benchmark’ах?",
    "explanation": "Логи ломают измерения производительности.",
    "answers": [
      {
        "text": "Вызывать функции"
      },
      {
        "text": "Аллоцировать память"
      },
      {
        "text": "Писать в лог",
        "correct": true
      },
      {
        "text": "Использовать цикл"
      }
    ]
  },
  {
    "topic_id": 8,
    "text": "Что в модели G-M-P определяет уровень реального параллелизма?",
    "explanation": "именно количество P (=GOMAXPROCS) определяет, сколько Go-кода может выполняться параллельно.",
    "answers": [
      {
        "text": "G (goroutine)"
      },
      {
        "text": "M (machine / OS thread)"
      },
      {
        "text": "P (processor)",
        "correct": true
      },
      {
        "text": "Количество созданных горутин"
      }
    ]
  },
  {
    "topic_id": 8,
    "text": "Может ли поток ОС (M) выполнять Go-код без P?",
    "explanation": "P — это «разрешение» на выполнение Go-кода.",
    "answers": [
      {
        "text": "Да, если есть готовая goroutine"
      },
      {
        "text": "Да, если GOMAXPROCS \u003e 1"
      },
      {
        "text": "Нет, M всегда должен быть привязан к P",
        "correct": true
      },
      {
        "text": "Зависит от версии Go"
      }
    ]
  },
  {
    "topic_id": 8,
    "text": "Что происходит, если goroutine делает блокирующий syscall?",
    "explanation": "поэтому Go нормально переживает blocking I/O.",
    "answers": [
      {
        "text": "Блокируется вся программа"
      },
      {
        "text": "Блокируется только текущий P"
      },
      {
        "text": "M отвязывается от P, P продолжает работу с другим M",
        "correct": true
      },
      {
        "text": "Все goroutine приостанавливаются"
      }
    ]
  },
  {
    "topic_id": 8,
    "text": "Чему по умолчанию равен GOMAXPROCS?",
    "explanation": "начиная с Go 1.5 — по умолчанию равен runtime.NumCPU().",
    "answers": [
      {
        "text": "1"
      },
      {
        "text": "Количеству goroutine"
      },
      {
        "text": "Количеству CPU ядер",
        "correct": true
      },
      {
        "text": "Количеству потоков ОС"
      }
    ]
  },
  {
    "topic_id": 8,
    "text": "Что из перечисленного может принудительно вытеснить goroutine (Go ≥ 1.14)?",
    "explanation": "с Go 1.14 появилась асинхронная preemption",
    "answers": [
      {
        "text": "Только channel operations"
      },
      {
        "text": "Только runtime.Gosched()"
      },
      {
        "text": "Планировщик runtime",
        "correct": true
      },
      {
        "text": "Только системные вызовы"
      }
    ]
  },
  {
    "topic_id": 8,
    "text": "Что такое work stealing?",
    "explanation": "это балансировка нагрузки без глобальной блокировки",
    "answers": [
      {
        "text": "Горутины крадут CPU время"
      },
      {
        "text": "Один P может забирать goroutine из очереди другого P",
        "correct": true
      },
      {
        "text": "M может забирать P у другого M"
      },
      {
        "text": "GC перераспределяет goroutine"
      }
    ]
  },
  {
    "topic_id": 8,
    "text": "Ситуация: GOMAXPROCS = 1, запущено 100 goroutine. Что верно?",
    "explanation": "concurrency ≠ parallelism",
    "answers": [
      {
        "text": "Они выполняются параллельно"
      },
      {
        "text": "Они выполняются конкурентно, но не параллельно",
        "correct": true
      },
      {
        "text": "Будет panic"
      },
      {
        "text": "Будет deadlock"
      }
    ]
  },
  {
    "topic_id": 8,
    "text": "Почему goroutine считаются «дешёвыми»?",
    "explanation": "старт ~2KB, растёт по мере необходимости",
    "answers": [
      {
        "text": "Они используют потоки ОС напрямую"
      },
      {
        "text": "У них маленький и растущий стек",
        "correct": true
      },
      {
        "text": "Они не используют стек"
      },
      {
        "text": "Их всегда выполняет отдельное ядро"
      }
    ]
  },
  {
    "topic_id": 8,
    "text": "Какой код потенциально опасен для планировщика (логически)?",
    "explanation": "даже с preemption он создаёт давление на scheduler и latency",
    "answers": [
      {
        "text": "time.Sleep(time.Second)"
      },
      {
        "text": "Чтение из канала"
      },
      {
        "text": "Бесконечный CPU-bound цикл без блокировок",
        "correct": true
      },
      {
        "text": "select {}"
      }
    ]
  },
  {
    "topic_id": 8,
    "text": "Что произойдёт, если все P заняты goroutine, ушедшими в syscall?",
    "explanation": "чтобы P могли продолжать выполнять Go-код.",
    "answers": [
      {
        "text": "Программа зависнет"
      },
      {
        "text": "Runtime создаст новые M",
        "correct": true
      },
      {
        "text": "Scheduler уменьшит GOMAXPROCS"
      },
      {
        "text": "Начнётся GC"
      }
    ]
  },
  {
    "topic_id": 15,
    "text": "Какие объекты участвуют в работе сборщика мусора Go?",
    "explanation": "Стек управляется компилятором и планировщиком, GC работает исключительно с heap.",
    "answers": [
      {
        "text": "Только объекты в куче (heap)",
        "correct": true
      },
      {
        "text": "Объекты в стеке и куче"
      },
      {
        "text": "Только объекты, созданные через new"
      },
      {
        "text": "Только объекты, переданные по указателю"
      }
    ]
  },
  {
    "topic_id": 15,
    "text": "Что означает параметр GOGC=100?",
    "explanation": "GOGC — это процент роста heap, а не время или загрузка CPU.",
    "answers": [
      {
        "text": "GC запускается каждые 100 мс"
      },
      {
        "text": "Heap может вырасти на 100% после прошлого GC",
        "correct": true
      },
      {
        "text": "GC использует 100% CPU"
      },
      {
        "text": "GC работает только при 100% заполнении памяти"
      }
    ]
  },
  {
    "topic_id": 15,
    "text": "Какой этап GC в Go выполняется конкурентно с программой?",
    "explanation": "Mark-фаза выполняется параллельно с пользовательскими горутинами, с write barrier.",
    "answers": [
      {
        "text": "Sweep"
      },
      {
        "text": "Mark",
        "correct": true
      },
      {
        "text": "Stop-the-world"
      },
      {
        "text": "Все вышеперечисленное"
      }
    ]
  },
  {
    "topic_id": 15,
    "text": "Зачем в Go используется write barrier?",
    "explanation": "Это сохраняет инвариант трёхцветного алгоритма при конкурентной маркировке.",
    "answers": [
      {
        "text": "Для ускорения аллокаций"
      },
      {
        "text": "Для предотвращения чёрных объектов, ссылающихся на белые",
        "correct": true
      },
      {
        "text": "Для блокировки горутин во время GC"
      },
      {
        "text": "Для очистки stack"
      }
    ]
  },
  {
    "topic_id": 15,
    "text": "Какое утверждение про Stop-the-World в Go верно?",
    "explanation": "STW в Go очень короткий (микросекунды), основная работа идёт конкурентно.",
    "answers": [
      {
        "text": "Go полностью не использует STW"
      },
      {
        "text": "STW используется только в начале и конце GC",
        "correct": true
      },
      {
        "text": "STW длится миллисекунды"
      },
      {
        "text": "STW блокирует только goroutines, но не system threads"
      }
    ]
  },
  {
    "topic_id": 15,
    "text": "Почему в Go нет классического generational GC?",
    "explanation": "Generational GC требует более дорогих барьеров и сложной модели памяти.",
    "answers": [
      {
        "text": "Из-за отсутствия указателей"
      },
      {
        "text": "Из-за сложности и стоимости write barrier",
        "correct": true
      },
      {
        "text": "Потому что Go не использует heap"
      },
      {
        "text": "Из-за ограничений планировщика"
      }
    ]
  },
  {
    "topic_id": 15,
    "text": "Какой код с большей вероятностью приведёт к аллокации в heap?",
    "code": "// Первый\r\nfunc f() {\r\n    x := 10\r\n    fmt.Println(x)\r\n}\r\n// Второй\r\nfunc f() *int {\r\n    x := 10\r\n    return \u0026x\r\n}",
    "explanation": "Возврат указателя → escape analysis отправляет x в heap.",
    "answers": [
      {
        "text": "Первый"
      },
      {
        "text": "Второй",
        "correct": true
      },
      {
        "text": "Оба"
      },
      {
        "text": "Ни один"
      }
    ]
  },
  {
    "topic_id": 15,
    "text": "Что произойдёт, если установить GOGC=off?",
    "explanation": "Heap будет расти без ограничений → риск OOM.",
    "answers": [
      {
        "text": "GC будет работать реже"
      },
      {
        "text": "GC будет отключён полностью",
        "correct": true
      },
      {
        "text": "GC станет stop-the-world"
      },
      {
        "text": "Ничего не изменится"
      }
    ]
  },
  {
    "topic_id": 15,
    "text": "Какой из вариантов увеличит нагрузку на GC сильнее всего?",
    "explanation": "fmt почти всегда создаёт временные heap-объекты.",
    "answers": [
      {
        "text": "Использование sync.Pool"
      },
      {
        "text": "Предаллоцированный slice"
      },
      {
        "text": "Частый fmt.Sprintf",
        "correct": true
      },
      {
        "text": "Использование value receiver"
      }
    ]
  },
  {
    "topic_id": 15,
    "text": "Почему высокая аллокация снижает throughput приложения?",
    "explanation": "GC работает на тех же P, что и твой код → меньше времени на полезную работу.",
    "answers": [
      {
        "text": "GC блокирует scheduler"
      },
      {
        "text": "GC отнимает CPU у пользовательских горутин",
        "correct": true
      },
      {
        "text": "GC увеличивает stack size"
      },
      {
        "text": "GC замедляет system calls"
      }
    ]
  },
  {
    "topic_id": 13,
    "text": "Что из перечисленного хранится в stack горутины?",
    "explanation": "Stack содержит данные, чей жизненный цикл ограничен вызовом функции в текущей горутине.",
    "answers": [
      {
        "text": "Локальные переменные функций",
        "correct": true
      },
      {
        "text": "Глобальные переменные"
      },
      {
        "text": "Данные map"
      },
      {
        "text": "Значения, на которые есть ссылки из других горутин"
      }
    ]
  },
  {
    "topic_id": 13,
    "text": "Какой стартовый размер стека у новой горутины в Go?",
    "explanation": "Go стартует с очень маленького стека и увеличивает его по мере необходимости.",
    "answers": [
      {
        "text": "Около 2 KB",
        "correct": true
      },
      {
        "text": "8 MB"
      },
      {
        "text": "Фиксированный и не меняется"
      },
      {
        "text": "Зависит от ОС"
      }
    ]
  },
  {
    "topic_id": 13,
    "text": "3. Что происходит при переполнении стека горутины?",
    "explanation": "В Go стек динамический, поэтому overflow обрабатывается прозрачно.",
    "answers": [
      {
        "text": "Go runtime расширяет стек и копирует данные",
        "correct": true
      },
      {
        "text": "Программа падает с stack overflow"
      },
      {
        "text": "Горутина завершается"
      },
      {
        "text": "Запускается GC"
      }
    ]
  },
  {
    "topic_id": 13,
    "text": "Может ли значение, созданное через new, находиться в stack?",
    "explanation": "Решает escape analysis, а не синтаксис создания значения.",
    "answers": [
      {
        "text": "Да, если оно не escape’ится",
        "correct": true
      },
      {
        "text": "Нет, new всегда кладёт в heap"
      },
      {
        "text": "Только если тип примитивный"
      },
      {
        "text": "Только в Go 1.22+"
      }
    ]
  },
  {
    "topic_id": 13,
    "text": "Почему stack-аллокaции быстрее heap?",
    "explanation": "Stack-память освобождается автоматически при выходе из функции.",
    "answers": [
      {
        "text": "Не требуют участия GC",
        "correct": true
      },
      {
        "text": "Не используют указатели"
      },
      {
        "text": "Происходят параллельно"
      },
      {
        "text": "Используют mmap"
      }
    ]
  },
  {
    "topic_id": 13,
    "text": "Какой код с большей вероятностью приведёт к escape в heap?",
    "explanation": "Значение должно жить дольше, чем стек текущей функции.",
    "answers": [
      {
        "text": "Возврат указателя на локальную переменную",
        "correct": true
      },
      {
        "text": "Возврат значения структуры"
      },
      {
        "text": "Использование локального int"
      },
      {
        "text": "Чтение из канала"
      }
    ]
  },
  {
    "topic_id": 13,
    "text": "Что такое stack frame?",
    "explanation": "Каждый вызов функции создаёт собственный frame в стеке.",
    "answers": [
      {
        "text": "Набор данных одного вызова функции",
        "correct": true
      },
      {
        "text": "Вся память горутины"
      },
      {
        "text": "Часть heap, закреплённая за функцией"
      },
      {
        "text": "Структура для передачи аргументов между горутинами"
      }
    ]
  },
  {
    "topic_id": 13,
    "text": "Что верно про рекурсию в Go?",
    "explanation": "Go безопасен для рекурсии, но бесконечная рекурсия приведёт к OOM.",
    "answers": [
      {
        "text": "Стек растёт динамически",
        "correct": true
      },
      {
        "text": "Всегда приводит к stack overflow"
      },
      {
        "text": "Запрещена компилятором"
      },
      {
        "text": "Использует heap вместо stack"
      }
    ]
  },
  {
    "topic_id": 13,
    "text": "Как узнать, ушла ли переменная из stack в heap?",
    "explanation": "Escape analysis выводится компилятором при этом флаге.",
    "answers": [
      {
        "text": "Использовать флаг компилятора -gcflags=\"-m\"",
        "correct": true
      },
      {
        "text": "Посмотреть runtime.MemStats"
      },
      {
        "text": "Включить race detector"
      },
      {
        "text": "Использовать pprof"
      }
    ]
  },
  {
    "topic_id": 13,
    "text": "Что верно про stack у горутин?",
    "explanation": "Это делает горутины дешёвыми и безопасными для конкурентного выполнения.",
    "answers": [
      {
        "text": "Каждая горутина имеет свой собственный стек",
        "correct": true
      },
      {
        "text": "Все горутины используют один общий стек"
      },
      {
        "text": "Стек разделяется между worker’ами"
      },
      {
        "text": "Стек фиксированного размера"
      }
    ]
  },
  {
    "topic_id": 13,
    "text": "Где будет размещена переменная x?",
    "code": "func foo() int {\r\n    x := 10\r\n    return x\r\n}",
    "explanation": "x используется только внутри функции и возвращается по значению, escape нет.",
    "answers": [
      {
        "text": "x в куче"
      },
      {
        "text": "x в стеке",
        "correct": true
      },
      {
        "text": "x размещается и там и там"
      },
      {
        "text": "зависит от версии Go"
      }
    ]
  },
  {
    "topic_id": 13,
    "text": "Где окажется x?",
    "code": "func foo() *int {\r\n    x := 10\r\n    return \u0026x\r\n}",
    "explanation": "адрес x возвращается наружу → значение должно жить дольше функции.",
    "answers": [
      {
        "text": "x в стеке"
      },
      {
        "text": "x в куче",
        "correct": true
      },
      {
        "text": "x в регистре"
      },
      {
        "text": "зависит от оптимизаций линковщика"
      }
    ]
  },
  {
    "topic_id": 13,
    "text": "Верно ли утверждение: «если есть указатель — значит heap»?",
    "explanation": "решает escape analysis, а не сам факт наличия указателя.",
    "answers": [
      {
        "text": "да, всегда"
      },
      {
        "text": "нет, указатель не гарантирует heap",
        "correct": true
      },
      {
        "text": "да, если указатель передаётся в другую функцию"
      },
      {
        "text": "да, начиная с Go 1.20"
      }
    ]
  },
  {
    "topic_id": 13,
    "text": "Что произойдёт с x?",
    "code": "func foo() {\r\n    x := 42\r\n    go func() {\r\n        fmt.Println(x)\r\n    }()\r\n}",
    "explanation": "замыкание в горутине живёт дольше foo.",
    "answers": [
      {
        "text": "x останется в стеке"
      },
      {
        "text": "x будет скопирован в горутину",
        "correct": true
      },
      {
        "text": "x уйдёт в кучу"
      },
      {
        "text": "код не скомпилируется"
      }
    ]
  },
  {
    "topic_id": 13,
    "text": "Почему interface{} часто приводит к heap-аллокациям?",
    "explanation": "конкретное значение кладётся в interface-обёртку, часто с escape.",
    "answers": [
      {
        "text": "из-за динамической типизации"
      },
      {
        "text": "из-за упаковки значения в интерфейс",
        "correct": true
      },
      {
        "text": "потому что interface всегда в куче"
      },
      {
        "text": "из-за reflect"
      }
    ]
  },
  {
    "topic_id": 13,
    "text": "Какой флаг показывает escape analysis компилятора?",
    "explanation": "компилятор выводит, какие значения «убегают» в heap.",
    "answers": [
      {
        "text": "-race"
      },
      {
        "text": "-gcflags=\"-m\"",
        "correct": true
      },
      {
        "text": "-benchmem"
      },
      {
        "text": "-escape"
      }
    ]
  },
  {
    "topic_id": 13,
    "text": "Что означает вывод 0 allocs/op в benchmark?",
    "explanation": "все данные размещены в стеке или оптимизированы.",
    "answers": [
      {
        "text": "GC отключён"
      },
      {
        "text": "нет heap-аллокаций",
        "correct": true
      },
      {
        "text": "нет стека"
      },
      {
        "text": "функция не выполнялась"
      }
    ]
  },
  {
    "topic_id": 13,
    "text": "Какой вариант уменьшит количество heap-аллокаций?",
    "code": "// вариант 1\r\nfunc NewUser() *User\r\n\r\n// вариант 2\r\nfunc NewUser() User",
    "explanation": "возврат значения позволяет остаться в стеке.",
    "answers": [
      {
        "text": "вариант 1"
      },
      {
        "text": "вариант 2",
        "correct": true
      },
      {
        "text": "разницы нет"
      },
      {
        "text": "зависит от размера структуры"
      }
    ]
  },
  {
    "topic_id": 13,
    "text": "Можно ли вручную указать Go, что переменная должна быть в стеке?",
    "explanation": "в Go нет ручного управления памятью.",
    "answers": [
      {
        "text": "да, через ключевое слово"
      },
      {
        "text": "да, через pragma"
      },
      {
        "text": "нет, это решает компилятор",
        "correct": true
      },
      {
        "text": "да, через unsafe"
      }
    ]
  },
  {
    "topic_id": 13,
    "text": "Почему большое количество heap-аллокаций вредно?",
    "explanation": "GC тратит время на сканирование и очистку кучи.",
    "answers": [
      {
        "text": "увеличивается размер бинарника"
      },
      {
        "text": "растёт нагрузка на GC",
        "correct": true
      },
      {
        "text": "замедляется стек"
      },
      {
        "text": "ломается scheduler"
      }
    ]
  },
  {
    "topic_id": 22,
    "text": "Что означает наличие data race в программе на Go?",
    "explanation": "Программа с гонкой данных считается некорректной. Компилятор и рантайм могут вести себя как угодно.",
    "answers": [
      {
        "text": "Программа может иногда работать неправильно"
      },
      {
        "text": "Результат выполнения не определён спецификацией Go",
        "correct": true
      },
      {
        "text": "Программа обязательно упадёт"
      },
      {
        "text": "Гонка влияет только на производительность"
      }
    ]
  },
  {
    "topic_id": 22,
    "text": "Что гарантирует отношение happens-before?",
    "explanation": "Happens-before гарантирует, что все записи памяти из первой операции будут видны во второй.",
    "answers": [
      {
        "text": "Порядок запуска горутин"
      },
      {
        "text": "Видимость изменений памяти между горутинами",
        "correct": true
      },
      {
        "text": "Отсутствие deadlock"
      },
      {
        "text": "Последовательность выполнения инструкций CPU"
      }
    ]
  },
  {
    "topic_id": 22,
    "text": "Создаёт ли time.Sleep отношение happens-before?",
    "explanation": "time.Sleep — это задержка, а не синхронизация. Он не даёт никаких гарантий видимости памяти.",
    "answers": [
      {
        "text": "Да, если sleep достаточно долгий"
      },
      {
        "text": "Да, если используется в main"
      },
      {
        "text": "Нет, никогда",
        "correct": true
      },
      {
        "text": "Только в тестах"
      }
    ]
  },
  {
    "topic_id": 22,
    "text": "Какое из действий гарантированно создаёт happens-before?",
    "explanation": "Отправка в канал happens-before соответствующего приёма.",
    "answers": [
      {
        "text": "Чтение глобальной переменной"
      },
      {
        "text": "Запись в канал и последующее чтение",
        "correct": true
      },
      {
        "text": "Вызов fmt.Println"
      },
      {
        "text": "Запуск горутины"
      }
    ]
  },
  {
    "topic_id": 22,
    "text": "Есть ли гонка в коде?",
    "code": "var x int\r\n\r\ngo func() {\r\n\tx = 1\r\n}()\r\n\r\nfmt.Println(x)",
    "explanation": "Атомарность операции ≠ happens-before. Нет синхронизации между горутинами.",
    "answers": [
      {
        "text": "Нет, int читается атомарно"
      },
      {
        "text": "Нет, запись простая"
      },
      {
        "text": "Да, есть data race",
        "correct": true
      },
      {
        "text": "Зависит от версии Go"
      }
    ]
  },
  {
    "topic_id": 22,
    "text": "Что из перечисленного НЕ является механизмом синхронизации?",
    "explanation": "Sleep не синхронизирует память и не создаёт happens-before.",
    "answers": [
      {
        "text": "Mutex"
      },
      {
        "text": "Channel"
      },
      {
        "text": "time.Sleep",
        "correct": true
      },
      {
        "text": "WaitGroup"
      }
    ]
  },
  {
    "topic_id": 22,
    "text": "Почему atomic-операции опасны при сложной логике?",
    "explanation": "Несколько atomic операций не являются атомарными вместе. Инварианты легко сломать.",
    "answers": [
      {
        "text": "Они медленные"
      },
      {
        "text": "Они блокируют scheduler"
      },
      {
        "text": "Они не защищают инварианты",
        "correct": true
      },
      {
        "text": "Они запрещены в production"
      }
    ]
  },
  {
    "topic_id": 22,
    "text": "Безопасен ли код?",
    "code": "done := make(chan struct{})\r\nvar data int\r\n\r\ngo func() {\r\n\tdata = 42\r\n\tclose(done)\r\n}()\r\n\r\n\u003c-done\r\nfmt.Println(data)",
    "explanation": "close(done) happens-before чтения из канала, значит запись data видна.",
    "answers": [
      {
        "text": "Нет, нужна mutex"
      },
      {
        "text": "Да, безопасен",
        "correct": true
      },
      {
        "text": "Зависит от планировщика"
      },
      {
        "text": "Безопасен только с buffered channel"
      }
    ]
  },
  {
    "topic_id": 22,
    "text": "Что гарантирует mu.Unlock() относительно mu.Lock()?",
    "explanation": "Unlock happens-before последующего Lock того же mutex.",
    "answers": [
      {
        "text": "Только освобождение mutex"
      },
      {
        "text": "Happens-before для следующего Lock",
        "correct": true
      },
      {
        "text": "Запуск планировщика"
      },
      {
        "text": "Сброс CPU кэша"
      }
    ]
  },
  {
    "topic_id": 22,
    "text": "Какой главный принцип конкурентного Go?",
    "explanation": "Либо передаём данные через каналы, либо синхронизируем доступ к общей памяти.",
    "answers": [
      {
        "text": "Использовать atomic вместо mutex"
      },
      {
        "text": "Избегать горутин"
      },
      {
        "text": "Не делить память без синхронизации",
        "correct": true
      },
      {
        "text": "Использовать как можно больше каналов"
      }
    ]
  }
]