[
  {
    "topic_id": 2,
    "text": "Что напечатает код?",
    "code": "s := []int{5, 6, 7}\ns2 := append(append(s, 8), 9)\nfmt.Println(len(s), cap(s))\n",
    "explanation": "append(s, 8) уже создало новый массив, но переменная s осталась нетронутой.",
    "answers": [
      {
        "text": "3 3",
        "correct": true
      },
      {
        "text": "3 4"
      },
      {
        "text": "3 6"
      },
      {
        "text": "3 8"
      }
    ]
  },
  {
    "topic_id": 2,
    "text": "Что напечатает код?",
    "code": "s := []int{1, 2, 3}\ns2 := s[:1]       // len=1, cap=3\ns3 := append(s2, 9)\nfmt.Println(s, s3)\n",
    "explanation": "append пишет в общую память: срез s тоже меняется.",
    "answers": [
      {
        "text": "[1 2 3] [1 9]"
      },
      {
        "text": "[1 9 3] [1 9]",
        "correct": true
      },
      {
        "text": "[1 9 3] [1 9 3]"
      },
      {
        "text": "[1 2 3] [1 2 3 9]"
      }
    ]
  },
  {
    "topic_id": 2,
    "text": "Что напечатает код?",
    "code": "s := make([]int, 2, 5)\ns2 := append(s, 7)\ns2[0] = 99\nfmt.Println(s[0])\n",
    "explanation": "Общий массив, так как при append вместимости хватает (5)",
    "answers": [
      {
        "text": "99",
        "correct": true
      },
      {
        "text": "0"
      },
      {
        "text": "7"
      },
      {
        "text": "Panic"
      }
    ]
  },
  {
    "topic_id": 2,
    "text": "Что напечатает код?",
    "code": "s := []int{10, 20, 30}\ns2 := s[:2]\ns2[1] = 99\nfmt.Println(s[1])\n",
    "explanation": "Подзрезка тоже же базового массива.\nПосле подрезки в s2 [10 20], len=2, cap=3",
    "answers": [
      {
        "text": "99",
        "correct": true
      },
      {
        "text": "20"
      },
      {
        "text": "30"
      },
      {
        "text": "Panic"
      }
    ]
  },
  {
    "topic_id": 2,
    "text": "Что напечатает код?",
    "code": "s := []int{1, 2, 3}\ns2 := append(s, 4)\ns2[0] = 99\nfmt.Println(s[0])\n",
    "explanation": "В начале len=3 cap=3, под срезом лежит массив [1 2 3]\nПосле добавления 4, нет свободного места создается НОВЫЙ базовый массив с cap=6, изменения идут уже у нового массива",
    "answers": [
      {
        "text": "1",
        "correct": true
      },
      {
        "text": "99"
      },
      {
        "text": "Runtime panic"
      },
      {
        "text": "Зависит от версии Go"
      }
    ]
  },
  {
    "topic_id": 9,
    "text": "Что произойдёт при исполнении?",
    "code": "ch := make(chan int)\ngo func() {\n    ch \u003c- 10\n}()\nfmt.Println(\u003c-ch)\n",
    "explanation": "Обычная синхронная передача данных.",
    "answers": [
      {
        "text": "Deadlock"
      },
      {
        "text": "10",
        "correct": true
      },
      {
        "text": "Panic: closed channel"
      },
      {
        "text": "Неопределенное поведение"
      }
    ]
  },
  {
    "topic_id": 4,
    "text": "Что выведет код?",
    "code": "m := make(map[string]int)\nm[\"a\"] = 1\nfor k := range m {\n    delete(m, k)\n}\nfmt.Println(len(m))\n",
    "explanation": "Go допускает удаление элементов из map во время итерации.",
    "answers": [
      {
        "text": "1"
      },
      {
        "text": "0",
        "correct": true
      },
      {
        "text": "panic"
      },
      {
        "text": "Неопределенное поведение"
      }
    ]
  },
  {
    "topic_id": 11,
    "text": "Для чего нужен интерфейс error?",
    "answers": [
      {
        "text": "Для обработки исключений"
      },
      {
        "text": "Для передачи ошибок как значений",
        "correct": true
      },
      {
        "text": "Чтобы логировать ошибки автоматически"
      },
      {
        "text": "Чтобы завершать программу"
      }
    ]
  },
  {
    "topic_id": 9,
    "text": "Какая коллекция в Go является потокобезопасной по умолчанию?",
    "answers": [
      {
        "text": "Map"
      },
      {
        "text": "Slice"
      },
      {
        "text": "Channel",
        "correct": true
      },
      {
        "text": "Array"
      }
    ]
  },
  {
    "topic_id": 9,
    "text": "Какой тип передается в канал chan int?",
    "answers": [
      {
        "text": "Только указатели на int"
      },
      {
        "text": "Только значения типа int",
        "correct": true
      },
      {
        "text": "Любые числа"
      },
      {
        "text": "Любые типы"
      }
    ]
  },
  {
    "topic_id": 9,
    "text": "Что произойдёт при записи в закрытый канал?",
    "answers": [
      {
        "text": "Ничего — значение игнорируется"
      },
      {
        "text": "Запись блокируется"
      },
      {
        "text": "Происходит panic",
        "correct": true
      },
      {
        "text": "Возвращается zero-value"
      }
    ]
  },
  {
    "topic_id": 13,
    "text": "Когда происходит escape в heap?",
    "answers": [
      {
        "text": "Когда переменная слишком большая"
      },
      {
        "text": "Когда значение нужно вернуть наружу и оно \"живет\" после выхода функции",
        "correct": true
      },
      {
        "text": "Когда в функции много переменных"
      },
      {
        "text": "Когда программа вызывает panic"
      }
    ]
  },
  {
    "topic_id": 7,
    "text": "Что такое goroutine?",
    "answers": [
      {
        "text": "Отдельный процесс ОС"
      },
      {
        "text": "Лёгкая потокоподобная сущность, управляемая рантаймом Go",
        "correct": true
      },
      {
        "text": "Поток ОС"
      },
      {
        "text": "Операция ввода-вывода"
      }
    ]
  },
  {
    "topic_id": 12,
    "text": "Что делает ключевое слово defer?",
    "explanation": "Откладывает выполнение функции до момента выхода из текущей функции (в том числе при return, панике, или обычном завершении).",
    "answers": [
      {
        "text": "Выполняет функцию асинхронно"
      },
      {
        "text": "Выполняет функцию после выхода из текущей функции",
        "correct": true
      },
      {
        "text": "Отменяет выполнение функции"
      },
      {
        "text": "Экспортирует функцию"
      }
    ]
  },
  {
    "topic_id": 5,
    "text": "Какой размер у пустой структуры struct{}?",
    "answers": [
      {
        "text": "1 байт"
      },
      {
        "text": "0 байт",
        "correct": true
      },
      {
        "text": "4 байта"
      },
      {
        "text": "Зависит от архитектуры"
      }
    ]
  },
  {
    "topic_id": 2,
    "text": "Что выведет код?",
    "code": "s1 := []int{1, 2, 3}\r\ns2 := make([]int, 3)\r\ncopy(s2, s1)\r\ns2[0] = 99\r\nfmt.Println(s1[0])",
    "explanation": "copy создаёт независимые массивы (если заранее выделена память). Изменения в s2 не влияют на s1.",
    "answers": [
      {
        "text": "1",
        "correct": true
      },
      {
        "text": "99"
      },
      {
        "text": "Зависит от компилятора"
      },
      {
        "text": "panic"
      }
    ]
  },
  {
    "topic_id": 2,
    "text": "Что выведет код?",
    "code": "s1 := []int{10, 20, 30}\r\ns2 := s1[:2]\r\ncopy(s2, []int{7})\r\nfmt.Println(s1)",
    "explanation": "s2 — подрезка того же массива. copy пишет в базовый массив.",
    "answers": [
      {
        "text": "[10 20 30]"
      },
      {
        "text": "[7 20 30]",
        "correct": true
      },
      {
        "text": "[7 7 30]"
      },
      {
        "text": "[7 20]"
      }
    ]
  },
  {
    "topic_id": 2,
    "text": "Что выведет код?",
    "code": "s1 := []int{1, 2, 3, 4}\r\ns2 := make([]int, 0, 4)\r\nn := copy(s2, s1)\r\nfmt.Println(n, len(s2), cap(s2))",
    "explanation": "copy копирует минимум(len(dst), len(src)).\r\nlen(dst) = 0 ⇒ копируется 0 элементов.",
    "answers": [
      {
        "text": "4 4 4"
      },
      {
        "text": "4 0 4"
      },
      {
        "text": "0 0 4",
        "correct": true
      },
      {
        "text": "panic"
      }
    ]
  },
  {
    "topic_id": 2,
    "text": "Что выведет код?",
    "code": "s1 := []int{1, 2, 3}\r\ns2 := make([]int, 5)\r\ncopy(s2, s1)\r\ns1 = append(s1, 9)\r\nfmt.Println(s2)",
    "explanation": "s2 — независимый массив.\r\nappend(s1, 9) создаёт новый массив (cap == len) и не влияет на s2.",
    "answers": [
      {
        "text": "[1 2 3 0 0]",
        "correct": true
      },
      {
        "text": "[1 2 3 9 0]"
      },
      {
        "text": "[1 2 3 0 9]"
      },
      {
        "text": "[9 2 3 0 0]"
      }
    ]
  },
  {
    "topic_id": 2,
    "text": "Что выведет код?",
    "code": "s1 := []int{5, 6, 7, 8}\r\ns2 := s1[1:3] // [6 7]\r\ns3 := make([]int, 2)\r\ncopy(s3, s2)\r\ns2[0] = 99\r\nfmt.Println(s1, s3)",
    "explanation": "s2 ссылается на тот же массив, что и s1.\r\ns3 — независимая копия.",
    "answers": [
      {
        "text": "[5 6 7 8] [6 7]"
      },
      {
        "text": "[5 99 7 8] [6 7]",
        "correct": true
      },
      {
        "text": "[5 99 7 8] [99 7]"
      },
      {
        "text": "[5 6 7 8] [99 7]"
      }
    ]
  },
  {
    "topic_id": 12,
    "text": "Что выведет Go?",
    "code": "x := 5\r\ndefer fmt.Println(x)\r\nx = 10",
    "explanation": "Аргументы defer вычисляются в момент его объявления.",
    "answers": [
      {
        "text": "5",
        "correct": true
      },
      {
        "text": "10"
      },
      {
        "text": "компилятор выдаст ошибку"
      },
      {
        "text": "undefined behavior"
      }
    ]
  },
  {
    "topic_id": 1,
    "text": "Что произойдёт, если читать из закрытого канала?",
    "explanation": "Чтение из закрытого канала безопасно: возвращается zero-value и флаг ok=false.",
    "answers": [
      {
        "text": "Возникнет паника"
      },
      {
        "text": "Горутина заблокируется навсегда"
      },
      {
        "text": "Вернётся нулевое значение типа и ok=false",
        "correct": true
      },
      {
        "text": "Чтение будет проигнорировано"
      }
    ]
  },
  {
    "topic_id": 1,
    "text": "Какой тип используется по умолчанию для неинициализированной переменной int?",
    "explanation": "Все переменные в Go инициализируются нулевыми значениями, для int — это 0",
    "answers": [
      {
        "text": "nil"
      },
      {
        "text": "undefined"
      },
      {
        "text": "0",
        "correct": true
      },
      {
        "text": "Минимальное значение int"
      }
    ]
  },
  {
    "topic_id": 1,
    "text": "Что означает «race condition» в Go?",
    "explanation": "«Гонка данных» — состояние, когда несколько горутин одновременно обращаются к разделяемым данным без синхронизации.",
    "answers": [
      {
        "text": "Ошибка синтаксиса"
      },
      {
        "text": "Конкурентное обновление общей переменной",
        "correct": true
      },
      {
        "text": "Некорректная работа GC"
      },
      {
        "text": "Ошибка сборки"
      }
    ]
  },
  {
    "topic_id": 1,
    "text": "Что делает оператор :=?",
    "explanation": ":= — короткое объявление переменной: одновременно создаёт её и присваивает значение",
    "answers": [
      {
        "text": "Только объявляет переменную"
      },
      {
        "text": "Только присваивает уже существующей переменной"
      },
      {
        "text": "Объявляет и присваивает переменной значение",
        "correct": true
      },
      {
        "text": "Работает только внутри циклов"
      }
    ]
  },
  {
    "topic_id": 9,
    "text": "Какой размер буфера у небуферизированного канала?",
    "explanation": "Небуферизированный канал имеет буфер 0 — отправитель и получатель должны встретиться",
    "answers": [
      {
        "text": "0",
        "correct": true
      },
      {
        "text": "1"
      },
      {
        "text": "64"
      },
      {
        "text": "Размер зависит от системы"
      }
    ]
  },
  {
    "topic_id": 1,
    "text": "Какой оператор завершает выполнение текущей итерации цикла?",
    "explanation": "continue пропускает оставшийся код итерации и переходит к следующей",
    "answers": [
      {
        "text": "break"
      },
      {
        "text": "stop"
      },
      {
        "text": "continue",
        "correct": true
      },
      {
        "text": "skip"
      }
    ]
  },
  {
    "topic_id": 1,
    "text": "Что делает go перед вызовом функции?",
    "explanation": "go f() запускает функцию асинхронно в новой горутине",
    "answers": [
      {
        "text": "Ничего, просто синтаксический сахар"
      },
      {
        "text": "Компилирует функцию иначе"
      },
      {
        "text": "Запускает её в отдельной горутине",
        "correct": true
      },
      {
        "text": "Присваивает ей больший приоритет"
      }
    ]
  },
  {
    "topic_id": 1,
    "text": "Что делает функция panic?",
    "explanation": "panic запускает раскрутку стека в текущей горутине. Если не поймана recover, приложение завершится.panic всегда уничтожает только ту горутину, в которой произошла. Но если это главная горутина, то программа завершается.",
    "answers": [
      {
        "text": "Завершает только текущую горутину",
        "correct": true
      },
      {
        "text": "Мягко выводит сообщение об ошибке"
      },
      {
        "text": "Немедленно завершает программу"
      },
      {
        "text": "Запускает механизм ошибок без выхода из функции"
      }
    ]
  },
  {
    "topic_id": 1,
    "text": "Что всегда делает panic?",
    "explanation": "Если это главная горутина и паника не перехвачена, то программа завершиться.",
    "answers": [
      {
        "text": "Запускает раскрутку стека в текущей горутине",
        "correct": true
      },
      {
        "text": "Немедленно завершает программу"
      },
      {
        "text": "Завершает все горутины"
      },
      {
        "text": "Прерывает выполнение функции без вызова defer"
      }
    ]
  },
  {
    "topic_id": 12,
    "text": "В каком порядке выполняются несколько defer?",
    "explanation": "defer работает как стек — последний добавленный выполняется первым. (LIFO)",
    "answers": [
      {
        "text": "В порядке объявления"
      },
      {
        "text": "В случайном порядке"
      },
      {
        "text": "В обратном порядке",
        "correct": true
      },
      {
        "text": "Параллельно"
      }
    ]
  },
  {
    "topic_id": 12,
    "text": "Когда НЕ выполнится defer?",
    "explanation": "Объяснение: os.Exit() немедленно завершает программу, defer при этом не выполняется.",
    "answers": [
      {
        "text": "При return"
      },
      {
        "text": "При panic"
      },
      {
        "text": "При os.Exit()",
        "correct": true
      },
      {
        "text": "При выходе из main"
      }
    ]
  },
  {
    "topic_id": 12,
    "text": "Что выведет код?",
    "code": "for i := 0; i \u003c 3; i++ {\r\n    defer fmt.Print(i)\r\n}",
    "explanation": "Каждый defer получает своё значение i, а выполняются они в обратном порядке.",
    "answers": [
      {
        "text": "012"
      },
      {
        "text": "210",
        "correct": true
      },
      {
        "text": "333"
      },
      {
        "text": "000"
      }
    ]
  },
  {
    "topic_id": 12,
    "text": "Что выведет код?",
    "code": "x := 5\r\n\r\ndefer func() {\r\n    fmt.Println(x)\r\n}()\r\n\r\nx = 10",
    "explanation": "defer откладывает вызов функции, но не копирует значения переменных внутри замыкания.\r\nАнонимная функция замыкает переменную x, а не её значение.\r\nЗначение x берётся в момент выполнения defer, то есть при выходе из функции, а не при объявлении defer.",
    "answers": [
      {
        "text": "10",
        "correct": true
      },
      {
        "text": "5"
      },
      {
        "text": "компилятор выдаст ошибку"
      },
      {
        "text": "undefined behavior"
      }
    ]
  },
  {
    "topic_id": 12,
    "text": "Что выведет код?",
    "code": "x := 5\r\n\r\ndefer func(x int) {\r\n    fmt.Println(x)\r\n}(x)\r\n\r\nx = 10",
    "explanation": "Потому что значение x передаётся аргументом и копируется в момент defer.",
    "answers": [
      {
        "text": "5",
        "correct": true
      },
      {
        "text": "10"
      },
      {
        "text": "компилятор выдаст ошибку"
      },
      {
        "text": "undefined behavior"
      }
    ]
  },
  {
    "topic_id": 12,
    "text": "Что выведет код?",
    "code": "for i := 0; i \u003c 3; i++ {\r\n    defer func() {\r\n        fmt.Print(i)\r\n    }()\r\n}",
    "explanation": "Начиная с Go 1.22, переменная цикла i в for i := ... создаётся заново на каждой итерации, а не одна на весь цикл.",
    "answers": [
      {
        "text": "210"
      },
      {
        "text": "333"
      },
      {
        "text": "222"
      },
      {
        "text": "Зависит от версии Go",
        "correct": true
      }
    ]
  },
  {
    "topic_id": 1,
    "text": "Что выведет код?",
    "code": "x := 10\r\nf := func() {\r\n    fmt.Println(x)\r\n}\r\nx = 20\r\nf()",
    "explanation": "Замыкания захватывают переменные, а не значения",
    "answers": [
      {
        "text": "20",
        "correct": true
      },
      {
        "text": "10"
      },
      {
        "text": "undefined behavior"
      },
      {
        "text": "компилятор выдаст ошибку"
      }
    ]
  },
  {
    "topic_id": 1,
    "text": "Что выведет код?",
    "code": "var i int\r\nfor i = 0; i \u003c 3; i++ {\r\n    defer func() {\r\n        fmt.Print(i)\r\n    }()\r\n}",
    "explanation": "Потому что i не создаётся внутри цикла.",
    "answers": [
      {
        "text": "3 3 3",
        "correct": true
      },
      {
        "text": "0 1 2"
      },
      {
        "text": "2 1 0"
      },
      {
        "text": "2 2 2"
      }
    ]
  },
  {
    "topic_id": 1,
    "text": "Что выведет код?",
    "code": "x := 1\r\nf := func() { x++ }\r\ng := func() { x++ }\r\n\r\nf()\r\ng()\r\nfmt.Println(x)",
    "explanation": "одно storage, два замыкания",
    "answers": [
      {
        "text": "1"
      },
      {
        "text": "2"
      },
      {
        "text": "3",
        "correct": true
      },
      {
        "text": "Ошибка"
      }
    ]
  },
  {
    "topic_id": 12,
    "text": "Почему defer внутри цикла может быть опасен?",
    "explanation": "Каждый defer кладётся в стек — в длинных циклах это может привести к лишнему расходу памяти",
    "answers": [
      {
        "text": "Он не выполнится"
      },
      {
        "text": "Он выполняется сразу"
      },
      {
        "text": "Он накапливает вызовы и потребляет память",
        "correct": true
      },
      {
        "text": "Он ломает panic"
      }
    ]
  },
  {
    "topic_id": 12,
    "text": "Можно ли использовать defer в горутине?",
    "explanation": "defer привязан к текущей горутине и выполняется при её завершении",
    "answers": [
      {
        "text": "Нет"
      },
      {
        "text": "Да, но он выполнится в main"
      },
      {
        "text": "Да, он выполнится при выходе из горутины",
        "correct": true
      },
      {
        "text": "Только с WaitGroup"
      }
    ]
  },
  {
    "topic_id": 12,
    "text": "Что выведет код?",
    "code": "func f() {\r\n    defer fmt.Println(\"world\")\r\n    fmt.Println(\"hello\")\r\n}",
    "explanation": "Сначала выполняется обычный код, затем — defer",
    "answers": [
      {
        "text": "world hello"
      },
      {
        "text": "hello world",
        "correct": true
      },
      {
        "text": "Только hello"
      },
      {
        "text": "Только world"
      }
    ]
  },
  {
    "topic_id": 12,
    "text": "Где чаще всего используется defer?",
    "explanation": "defer идеально подходит для Close(), Unlock(), Recover() — гарантирует очистку ресурсов.",
    "answers": [
      {
        "text": "Для циклов"
      },
      {
        "text": "Для освобождения ресурсов",
        "correct": true
      },
      {
        "text": "Для ускорения кода"
      },
      {
        "text": "Для логирования только"
      }
    ]
  },
  {
    "topic_id": 12,
    "text": "Как defer ведёт себя с именованным return?",
    "code": "func f() (x int) {\r\n    defer func() {\r\n        x++\r\n    }()\r\n    return 1\r\n}",
    "explanation": "defer выполняется после присваивания return-значения, но до выхода из функции",
    "answers": [
      {
        "text": "Вернёт 1"
      },
      {
        "text": "Вернёт 2",
        "correct": true
      },
      {
        "text": "Вернёт 0"
      },
      {
        "text": "Паника"
      }
    ]
  }
]