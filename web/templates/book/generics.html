{{ define "book.generics" }}
<h1>Generics (–û–±–æ–±—â–µ–Ω–∏—è)</h1>
<p>Generics (–æ–±–æ–±—â–µ–Ω–∏—è) –≤ Go –ø–æ—è–≤–∏–ª–∏—Å—å –Ω–∞—á–∏–Ω–∞—è —Å <b>Go 1.18</b> –∏ —Å–∏–ª—å–Ω–æ —É–ø—Ä–æ—Å—Ç–∏–ª–∏ –Ω–∞–ø–∏—Å–∞–Ω–∏–µ <b>–ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º–æ–≥–æ –∏
    —Ç–∏–ø–æ–±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ</b> –∫–æ–¥–∞ ‚Äî –±–µ–∑ <code>interface{}</code> –∏ –∫–∞—Å—Ç–æ–≤.</p>
<pre><code class="language-go">func Identity[T any](v T) T {
    return v
}</code></pre>
<p>–ö–æ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å</p>
<p>‚úÖ –ò—Å–ø–æ–ª—å–∑—É–π, –µ—Å–ª–∏:</p>
<ul>
    <li>–ê–ª–≥–æ—Ä–∏—Ç–º –æ–¥–∏–Ω–∞–∫–æ–≤—ã–π</li>
    <li>–†–∞–∑–Ω—ã–µ —Ç–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö</li>
    <li>–ù—É–∂–Ω–∞ —Ç–∏–ø–æ–±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å</li>
</ul>
<p>‚ùå –ù–µ –∏—Å–ø–æ–ª—å–∑—É–π, –µ—Å–ª–∏:</p>
<ul>
    <li>–†–∞–∑–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ</li>
    <li>–õ–æ–≥–∏–∫–∞ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Ç–∏–ø–∞</li>
    <li>–ú–æ–∂–Ω–æ –æ–±–æ–π—Ç–∏—Å—å –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–º</li>
</ul>

<h2>1. –ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ</h2>
<p>–î–æ generics –±—ã–ª–æ –¥–≤–∞ –≤–∞—Ä–∏–∞–Ω—Ç–∞:</p>
<h3>‚ùå –î—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ</h3>
<pre><code class="language-go">func MaxInt(a, b int) int       { if a > b { return a }; return b }
func MaxFloat(a, b float64) float64 { ... }</code></pre>
<h3>‚ùå interface{} + type assertion</h3>
<pre><code class="language-go">func Max(a, b interface{}) interface{} {
	ai := a.(int) // üí• panic –µ—Å–ª–∏ –Ω–µ int
}</code></pre>

<h2>2. –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —Ç–∏–ø–æ–≤</h2>
<p>any ‚Äî –ª—é–±–æ–π —Ç–∏–ø</p>
<pre><code class="language-go">func Print[T any](v T) {
    fmt.Println(v)
}</code></pre>
<p>comparable ‚Äî –º–æ–∂–Ω–æ —Å—Ä–∞–≤–Ω–∏–≤–∞—Ç—å <code>== !=</code></p>
<pre><code class="language-go">func Contains[T comparable](s []T, v T) bool {
    for _, x := range s {
        if x == v {
            return true
        }
    }
    return false
}</code></pre>
<p>‚úî –†–∞–±–æ—Ç–∞–µ—Ç —Å:</p>
<ul>
    <li>int</li>
    <li>string</li>
    <li>struct (–µ—Å–ª–∏ –≤—Å–µ –ø–æ–ª—è comparable)</li>
</ul>
<p>‚ùå –ù–µ —Ä–∞–±–æ—Ç–∞–µ—Ç —Å:</p>
<ul>
    <li>slice</li>
    <li>map</li>
    <li>func</li>
</ul>

<h2>3. –°–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–µ constraints (–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã —Ç–∏–ø–æ–≤)</h2>
<p>–ü—Ä–∏–º–µ—Ä: —á–∏—Å–ª–∞</p>
<pre><code class="language-go">type Number interface {
    int | int64 | float64
}

func Sum[T Number](a, b T) T {
    return a + b
}</code></pre>
<p>
    ‚úî <code>Sum(1, 2)</code><br>
    ‚úî <code>Sum(1.5, 2.5)</code><br>
    ‚ùå <code>Sum("a", "b")</code>
</p>

<h2>4. Generics + —Å—Ç—Ä—É–∫—Ç—É—Ä—ã</h2>
<pre><code class="language-go">type Box[T any] struct {
    Value T
}

b := Box[int]{Value: 10}
s := Box[string]{Value: "hi"}</code></pre>

<p>üìå –û—á–µ–Ω—å –ø–æ–ª–µ–∑–Ω–æ –¥–ª—è:</p>
<ul>
    <li>DTO</li>
    <li>Result / Option</li>
    <li>Cache</li>
    <li>Queue / Stack</li>
</ul>

<h2>5. –ú–µ—Ç–æ–¥—ã —Å generics ‚Äî –í–ê–ñ–ù–û</h2>
<p>‚ùå –ú–µ—Ç–æ–¥—ã –ù–ï –º–æ–≥—É—Ç –∏–º–µ—Ç—å —Å–≤–æ–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Ç–∏–ø–∞</p>
<pre><code class="language-go">func (b Box[T]) Map[R any](f func(T) R) R { ‚ùå }</code></pre>
<p>‚úî –ù—É–∂–Ω–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏–∑–æ–≤–∞—Ç—å —Ç–∏–ø, –∞ –Ω–µ –º–µ—Ç–æ–¥:</p>
<pre><code class="language-go">type Box[T any] struct {
    Value T
}</code></pre>

<h2>6. Generics vs interface{} ‚Äî –∫–ª—é—á–µ–≤–∞—è —Ä–∞–∑–Ω–∏—Ü–∞</h2>
<table>
    <thead>
    <tr>
        <th>interface{}</th>
        <th>Generics</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td>–ù–µ—Ç –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ç–∏–ø–æ–≤</td>
        <td>–ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ compile-time</td>
    </tr>
    <tr>
        <td>–ù—É–∂–Ω—ã –∫–∞—Å—Ç—ã</td>
        <td>–ù–µ—Ç –∫–∞—Å—Ç–æ–≤</td>
    </tr>
    <tr>
        <td>–í–æ–∑–º–æ–∂–µ–Ω panic</td>
        <td>–ë–µ–∑–æ–ø–∞—Å–Ω–æ</td>
    </tr>
    <tr>
        <td>–ú–µ–¥–ª–µ–Ω–Ω–µ–µ</td>
        <td>–ë—ã—Å—Ç—Ä–µ–µ</td>
    </tr>
    </tbody>
</table>


{{ end }}