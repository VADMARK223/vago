{{ define "book.sync" }}
<h1>–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è</h1>
<a href="#mutex">sync.Mutex (RWMutex)</a>
<a href="#waitGroup">sync.WaitGroup</a>
<a href="#atomic">–ê—Ç–æ–º–∏–∫–∏</a>
<a href="/book?chapter_id=16">–†–∞–∑–¥–µ–ª: 16. "–ö–æ–Ω—Ç–µ–∫—Å—Ç (Context)"</a>
<a href="#package_sync">–ü–∞–∫–µ—Ç sync</a>
<a href="#classic_problems">–ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–±–ª–µ–º—ã</a>
<p><b>–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –≤ Go</b> ‚Äî —ç—Ç–æ –Ω–∞–±–æ—Ä –º–µ—Ö–∞–Ω–∏–∑–º–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–∑–≤–æ–ª—è—é—Ç <b>–±–µ–∑–æ–ø–∞—Å–Ω–æ –∫–æ–æ—Ä–¥–∏–Ω–∏—Ä–æ–≤–∞—Ç—å —Ä–∞–±–æ—Ç—É –≥–æ—Ä—É—Ç–∏–Ω –∏
    –∑–∞—â–∏—â–∞—Ç—å –æ–±—â–∏–µ –¥–∞–Ω–Ω—ã–µ</b> –æ—Ç –≥–æ–Ω–æ–∫.</p>
<hr>
<h2>–ó–∞—á–µ–º –≤–æ–æ–±—â–µ –Ω—É–∂–Ω–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è</h2>
<p>–ï—Å–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ –≥–æ—Ä—É—Ç–∏–Ω:</p>
<ul>
    <li>—á–∏—Ç–∞—é—Ç –∏ –ø–∏—à—É—Ç <b>–æ–¥–Ω—É –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é</b></li>
    <li>—Ä–∞–±–æ—Ç–∞—é—Ç —Å <b>–æ–±—â–µ–π —Å—Ç—Ä—É–∫—Ç—É—Ä–æ–π –¥–∞–Ω–Ω—ã—Ö</b></li>
    <li>–¥–æ–ª–∂–Ω—ã <b>–¥–æ–∂–¥–∞—Ç—å—Å—è –¥—Ä—É–≥ –¥—Ä—É–≥–∞</b></li>
</ul>
<p>‚Üí –±–µ–∑ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –ø–æ–ª—É—á–∏—à—å <b>data race</b>, –Ω–µ–æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ –∏–ª–∏ –ø–∞–¥–µ–Ω–∏—è.</p>

<h2 id="mutex">sync.Mutex</h2>
<p>–í –æ–¥–∏–Ω –º–æ–º–µ–Ω—Ç –≤—Ä–µ–º–µ–Ω–∏ <b>—Ç–æ–ª—å–∫–æ –æ–¥–Ω–∞ –≥–æ—Ä—É—Ç–∏–Ω–∞</b> –º–æ–∂–µ—Ç –≤–æ–π—Ç–∏ –≤ –∫—Ä–∏—Ç–∏—á–µ—Å–∫—É—é —Å–µ–∫—Ü–∏—é.</p>
<pre><code class="language-go">var mu sync.Mutex
var counter int

func inc() {
    mu.Lock()
    counter++
    mu.Unlock()
}

// –•–æ—Ä–æ—à–∞—è –ø—Ä–∞–∫—Ç–∏–∫–∞
func inc1() {
    defer mu.Unlock()
    mu.Lock()
    counter++
}
</code></pre>
<p>–í–∞–∂–Ω–æ –ø–æ–º–Ω–∏—Ç—å</p>
<ul>
    <li><code>Lock()</code> –±–ª–æ–∫–∏—Ä—É–µ—Ç <b>–≥–æ—Ä—É—Ç–∏–Ω—ã</b>, –Ω–µ –ø–æ—Ç–æ–∫–∏</li>
    <li>–ó–∞–±—ã—Ç—ã–π <code>Unlock()</code> = –¥–µ–¥–ª–æ–∫</li>
    <li>‚ùå –ù–µ–ª—å–∑—è –∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å <code>Mutex</code></li>
</ul>

<h3>sync.RWMutex</h3>
<p>–ö–æ–≥–¥–∞ –Ω—É–∂–µ–Ω</p>
<ul>
    <li>–ú–Ω–æ–≥–æ —á—Ç–µ–Ω–∏–π</li>
    <li>–†–µ–¥–∫–∏–µ –∑–∞–ø–∏—Å–∏</li>
</ul>
<pre><code class="language-go">var mu sync.RWMutex
var data map[string]int

func read(k string) int {
    mu.RLock()
    defer mu.RUnlock()
    return data[k]
}

func write(k string, v int) {
    mu.Lock()
    defer mu.Unlock()
    data[k] = v
}
</code></pre>
<p>–ü–æ–¥–≤–æ–¥–Ω—ã–µ –∫–∞–º–Ω–∏</p>
<ul>
    <li>–ü–∏—Å–∞—Ç–µ–ª–∏ –±–ª–æ–∫–∏—Ä—É—é—Ç –≤—Å–µ—Ö</li>
    <li>–ù–µ –∞–ø–≥—Ä–µ–π–¥–∏—Ç—Å—è <code>RLock ‚Üí Lock</code></li>
</ul>

<h2 id="waitGroup">sync.WaitGroup</h2>
<p>–ü–æ–∑–≤–æ–ª—è–µ—Ç –¥–æ–∂–¥–∞—Ç—å—Å—è –≥–æ—Ä—É—Ç–∏–Ω—ã</p>
<pre><code class="language-go">var wg sync.WaitGroup

for i := 0; i < 3; i++ {
    wg.Add(1)
    go func(i int) {
        defer wg.Done()
        fmt.Println(i)
    }(i)
}

wg.Wait()</code></pre>
<p>–ß–∞—Å—Ç—ã–µ –æ—à–∏–±–∫–∏</p>
<ul>
    <li>‚ùå <code>Add()</code> –≤–Ω—É—Ç—Ä–∏ –≥–æ—Ä—É—Ç–∏–Ω—ã</li>
    <li>‚ùå <code>Done()</code> –∑–∞–±—ã–ª–∏</li>
    <li>‚ùå –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–π —Å—á—ë—Ç—á–∏–∫</li>
</ul>

<h2 id="atomic">–ê—Ç–æ–º–∏–∫–∏</h2>
<pre><code class="language-go">var x int64
atomic.AddInt64(&x, 1)
</code></pre>
<p>–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è</p>
<ul>
    <li>—Ç–æ–ª—å–∫–æ –ø—Ä–∏–º–∏—Ç–∏–≤—ã</li>
    <li>–Ω–µ—Ç –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –æ–ø–µ—Ä–∞—Ü–∏–π</li>
    <li>—Å–ª–æ–∂–Ω–æ —á–∏—Ç–∞—Ç—å –∏ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å</li>
</ul>

<h2>Context - –∫–æ–æ—Ä–¥–∏–Ω–∞—Ü–∏—è –æ—Ç–º–µ–Ω—ã</h2>
<a href="/book?chapter_id=16">–†–∞–∑–¥–µ–ª: 16. "–ö–æ–Ω—Ç–µ–∫—Å—Ç (Context)"</a>
{{ template "book.common.context" . }}

<h2>–ö–∞–Ω–∞–ª—ã –∫–∞–∫ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è</h2>
<h3>–ö–∞–Ω–∞–ª = –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ + –ø–µ—Ä–µ–¥–∞—á–∞ –¥–∞–Ω–Ω—ã—Ö</h3>
<pre><code class="language-go">ch := make(chan int)

go func() {
    ch <- 42 // –±–ª–æ–∫–∏—Ä—É–µ—Ç—Å—è –ø–æ–∫–∞ –Ω–µ –ø—Ä–æ—á–∏—Ç–∞—é—Ç
}()

v := <-ch</code></pre>

<h3>–ö–∞–Ω–∞–ª –≤–º–µ—Å—Ç–æ Mutex</h3>
<pre><code class="language-go">type Counter struct {
    inc chan struct{}
    val chan int
}

func NewCounter() *Counter {
    c := &Counter{
        inc: make(chan struct{}),
        val: make(chan int),
    }
    go c.loop()
    return c
}

func (c *Counter) loop() {
    var n int
    for {
        select {
        case <-c.inc:
            n++
        case c.val <- n:
        }
    }
}</code></pre>

<h2 id="package_sync">–ü–∞–∫–µ—Ç sync</h2>
<h3>sync.Once ‚Äî –≤—ã–ø–æ–ª–Ω–∏—Ç—å —Ä–æ–≤–Ω–æ –æ–¥–∏–Ω —Ä–∞–∑</h3>
<pre><code class="language-go">var once sync.Once

func initConfig() {
    once.Do(func() {
        fmt.Println("init")
    })
}</code></pre>
<p>–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è:</p>
<ul>
    <li>lazy init</li>
    <li>singleton</li>
    <li>–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∫—ç—à–∞</li>
</ul>
<h3>sync.Cond ‚Äî —É—Å–ª–æ–≤–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ (—Ä–µ–¥–∫–æ, –Ω–æ –º–æ—â–Ω–æ)</h3>
<pre><code class="language-go">cond := sync.NewCond(&sync.Mutex{})
ready := false

go func() {
    cond.L.Lock()
    ready = true
    cond.Signal()
    cond.L.Unlock()
}()

cond.L.Lock()
for !ready {
    cond.Wait()
}
cond.L.Unlock()</code></pre>
<p>üìå –ò—Å–ø–æ–ª—å–∑—É–π, –∫–æ–≥–¥–∞:</p>
<ul>
    <li>–µ—Å—Ç—å —Å–ª–æ–∂–Ω—ã–µ —É—Å–ª–æ–≤–∏—è</li>
    <li>–∫–∞–Ω–∞–ª—ã —Å—Ç–∞–Ω–æ–≤—è—Ç—Å—è –Ω–µ—É–¥–æ–±–Ω—ã–º–∏</li>
</ul>

<h2 id="classic_problems">üî• –ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–±–ª–µ–º—ã</h2>
<table>
    <thead>
    <tr>
        <th>–ü—Ä–æ–±–ª–µ–º–∞</th>
        <th>–ü—Ä–∏—á–∏–Ω–∞</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td>Data race</td>
        <td>–Ω–µ—Ç —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏</td>
    </tr>
    <tr>
        <td>Deadlock</td>
        <td>–∑–∞–±—ã–ª–∏ Unlock / —Ü–∏–∫–ª–∏—á–µ—Å–∫–∞—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞</td>
    </tr>
    <tr>
        <td>Livelock</td>
        <td>–≥–æ—Ä—É—Ç–∏–Ω—ã –º–µ—à–∞—é—Ç –¥—Ä—É–≥ –¥—Ä—É–≥—É</td>
    </tr>
    <tr>
        <td>Starvation</td>
        <td>RWMutex, –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç —á–∏—Ç–∞—Ç–µ–ª–µ–π</td>
    </tr>
    </tbody>
</table>
<p>–ü—Ä–æ–≤–µ—Ä–∫–∞:</p>
<pre><code class="language-go">go test -race</code></pre>

{{ end }}