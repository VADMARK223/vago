{{ define "book.testing" }}
<h1>–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ</h1>
<h2>–ë–∞–∑–æ–≤–æ–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ (<code>testing</code>)</h2>
<p>–í Go <b>–≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π</b> —Ñ—Ä–µ–π–º–≤–æ—Ä–∫ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è ‚Äî –ø–∞–∫–µ—Ç <code>testing</code>.</p>
<p>üìå <b>–ü—Ä–∞–≤–∏–ª–∞</b></p>
<ul>
    <li>–§–∞–π–ª—ã: <code>*_test.go</code></li>
    <li>–¢–µ—Å—Ç—ã: <code>func TestXxx(t *testing.T)</code></li>
    <li>
        –ü–∞–∫–µ—Ç:
        <ul>
            <li><code>package foo</code> ‚Äî white-box</li>
            <li><code>package foo_test</code> ‚Äî black-box (—á–∞—Å—Ç–æ —Ü–µ–Ω–∏—Ç—Å—è –≤—ã—à–µ, –ø–æ—Ç–æ–º—É —á—Ç–æ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –ø—É–±–ª–∏—á–Ω—ã–π API –ø–∞–∫–µ—Ç–∞.)</li>
        </ul>
    </li>
</ul>
<pre><code class="language-go">func TestSum(t *testing.T) {
    res := Sum(2, 3)
    if res != 5 {
        t.Fatalf("expected 5, got %d", res)
    }
}</code></pre>
<p>–ó–∞–ø—É—Å–∫ (–≤–µ—Å—å –ø—Ä–æ–µ–∫—Ç):</p>
<pre><code class="language-go">go test ./...</code></pre>
<p>–ó–∞–ø—É—Å–∫ (–∫–æ–Ω–∫—Ä–µ—Ç–Ω—É—é –ø–∞–ø–∫—É):</p>
<p>–§–ª–∞–≥ <code>-v</code> –≤—ã–≤–æ–¥–∏—Ç –ø–æ–¥—Ä–æ–±–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é</p>
<p>–§–ª–∞–≥ <code>-cover</code> –ø—Ä–æ—Ü–µ–Ω—Ç –ø–æ–∫—Ä—ã—Ç–∏—è –∫–æ–¥–∞ —Ç–µ—Å—Ç–∞–º–∏</p>
<pre><code class="language-go">go test ./cmd/folder...</code></pre>
<hr>
<h2>Table-driven tests</h2>
<p>–ö–∞–Ω–æ–Ω–∏—á–µ—Å–∫–∏–π –ø—Ä–∏–º–µ—Ä</p>
<pre><code class="language-go">func TestAbs(t *testing.T) {
    testTable := []struct {
        name string // –ù–∞–∑–≤–∞–Ω–∏–µ —Ç–µ—Å—Ç–∞
        in   int
        want int
    }{
        {"positive", 5, 5},
        {"negative", -5, 5},
        {"zero", 0, 0},
    }

    for _, tt := range testTable {
        t.Run(tt.name, func(t *testing.T) {
            if got := Abs(tt.in); got != tt.want {
                t.Errorf("Abs(%d) = %d, want %d", tt.in, got, tt.want)
            }
        })
    }
}</code></pre>
<p>‚ö†Ô∏è –í–∞–∂–Ω–æ:
    –î–æ Go 1.22 –±—ã–ª –±–∞–≥ —Å –∑–∞—Ö–≤–∞—Ç–æ–º <code>tt</code>, —Å–µ–π—á–∞—Å –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–æ, –Ω–æ <code>tt := tt</code> –≤—Å—ë –µ—â—ë –≤—Å—Ç—Ä–µ—á–∞–µ—Ç—Å—è –≤ –∫–æ–¥–µ.</p>

<hr>
<h2>Subtests (<code>r.Run</code>)</h2>
<p>–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è:</p>
<ul>
    <li>–ª–æ–≥–∏—á–µ—Å–∫–æ–π –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∏</li>
    <li>–ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã—Ö —Ç–µ—Å—Ç–æ–≤</li>
    <li>—á–∏—Ç–∞–µ–º—ã—Ö –æ—Ç—á—ë—Ç–æ–≤</li>
</ul>
<pre><code class="language-go">func TestService(t *testing.T) {
    t.Run("success", func(t *testing.T) {})
    t.Run("not_found", func(t *testing.T) {})
}</code></pre>

<hr>
<h2>–ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–µ —Ç–µ—Å—Ç—ã</h2>
<pre><code class="language-go">func TestParallel(t *testing.T) {
    t.Parallel()
    time.Sleep(time.Second)
}</code></pre>
<p>üìå –ù–µ–ª—å–∑—è <code>t.Parallel()</code>:</p>
<ul>
    <li>–ø—Ä–∏ shared state</li>
    <li>–ø—Ä–∏ —Ä–∞–±–æ—Ç–µ —Å env</li>
    <li>–ø—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ –æ–¥–Ω–æ–π –ë–î / –æ–¥–Ω–æ–≥–æ —Ñ–∞–π–ª–∞</li>
</ul>

<hr>
<h2>Setup / Teardown</h2>
<p>–í Go <b>–Ω–µ—Ç beforeEach/afterEach</b>, –≤—Å—ë –¥–µ–ª–∞–µ—Ç—Å—è —Ä—É–∫–∞–º–∏:</p>
<pre><code class="language-go">func TestMain(m *testing.M) {
    setup()
    code := m.Run()
    teardown()
    os.Exit(code)
}</code></pre>
<p>–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ä–µ–¥–∫–æ, –Ω–æ –æ—á–µ–Ω—å <b>–≤–∞–∂–Ω–æ –∑–Ω–∞—Ç—å</b>.</p>

<hr>
<h2>–ü—Ä–æ–≤–µ—Ä–∫–∏ –æ—à–∏–±–æ–∫ (–ø—Ä–∞–≤–∏–ª—å–Ω–æ!)</h2>
<p>‚ùå –ü–ª–æ—Ö–æ:</p>
<pre><code class="language-go">if err != nil {
    t.Fatal(err)
}</code></pre>
<p>‚úÖ –•–æ—Ä–æ—à–æ:</p>
<pre><code class="language-go">if err != nil {
    t.Fatal("expected error, got nil")
}</code></pre>
<p>–ò–ª–∏:</p>
<pre><code class="language-go">if !errors.Is(err, ErrNotFound) {
    t.Fatalf("expected ErrNotFound, got %v", err)
}</code></pre>

<hr>
<h2>Mock‚Äô–∏ –≤ Go</h2>
<p>–í Go –Ω–µ—Ç –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã—Ö <b>mock‚Äô–æ–≤</b>, –≤—Å—ë —á–µ—Ä–µ–∑ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã.</p>
<h3>–†—É—á–Ω–æ–π mock</h3>
<pre><code class="language-go">type mockRepo struct {
    data map[int]string
}

func (m *mockRepo) Get(id int) (string, error) {
    v, ok := m.data[id]
    if !ok {
        return "", ErrNotFound
    }
    return v, nil
}</code></pre>
<p>–†—É—á–Ω—ã–µ mock'–∏:</p>
<ul>
    <li>–ø—Ä–æ—â–µ</li>
    <li>–º–µ–Ω—å—à–µ –º–∞–≥–∏–∏</li>
    <li>—Ç–∏–ø–æ–±–µ–∑–æ–ø–∞—Å–Ω–æ</li>
    <li>—á–∏—Ç–∞–µ–º–æ</li>
</ul>

<hr>
<h2>–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ HTTP (Gin / net/http)</h2>
<pre><code class="language-go">req := httptest.NewRequest(http.MethodGet, "/ping", nil)
w := httptest.NewRecorder()

router.ServeHTTP(w, req)

if w.Code != http.StatusOK {
    t.Fatalf("expected 200, got %d", w.Code)
}</code></pre>

<hr>
<h2>–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ concurrency</h2>
<h3>–ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–µ–¥–ª–æ–∫–æ–≤</h3>
<pre><code class="language-go">done := make(chan struct{})
go func() {
    work()
    close(done)
}()

select {
case <-done:
case <-time.After(time.Second):
    t.Fatal("deadlock")
}</code></pre>
<code>-race</code>
<pre><code class="language-go">go test -race ./...</code></pre>

<hr>
<h2>Benchmark‚Äô–∏</h2>
<pre><code class="language-go">func BenchmarkSum(b *testing.B) {
    for i := 0; i < b.N; i++ {
        Sum(2, 3)
    }
}</code></pre>
<p>–ó–∞–ø—É—Å–∫:</p>
<pre><code class="language-go">go test -bench=. -benchmem</code></pre>
<blockquote class="note">–õ–æ–≥–∏ –≤ benchmark –ø–∏—Å–∞—Ç—å –Ω–µ–ª—å–∑—è. (–õ–æ–≥–∏ –ª–æ–º–∞—é—Ç –∏–∑–º–µ—Ä–µ–Ω–∏—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏.)</blockquote>

<hr>
<h2>Fuzz-—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ (Go ‚â• 1.18)</h2>
<pre><code class="language-go">func FuzzReverse(f *testing.F) {
    f.Add("hello")

    f.Fuzz(func(t *testing.T, s string) {
        r := Reverse(s)
        if Reverse(r) != s {
            t.Fatalf("broken")
        }
    })
}</code></pre>

<hr>
<h2>–ß—Ç–æ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ —Å–ø—Ä–æ—Å—è—Ç –Ω–∞ —Å–æ–±–µ—Å–µ</h2>
<p>–ß–µ–∫–ª–∏—Å—Ç:</p>
<ul>
    <li>‚úÖ table-driven tests</li>
    <li>‚úÖ t.Parallel</li>
    <li>‚úÖ TestMain</li>
    <li>‚úÖ mock —á–µ—Ä–µ–∑ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã</li>
    <li>‚úÖ go test -race</li>
    <li>‚úÖ black-box vs white-box</li>
</ul>














{{ end }}