{{ define "book.testing" }}
<h1>–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ</h1>
<a href="#theory">–¢–µ–æ—Ä–∏—è</a>
<a href="#unit-test">Unit-—Ç–µ—Å—Ç (–ü—Ä–∏–º–µ—Ä)</a>
<hr>

<h2 id="theory">–ë–∞–∑–æ–≤–æ–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ (<code>testing</code>)</h2>
<p>–í Go <b>–≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π</b> —Ñ—Ä–µ–π–º–≤–æ—Ä–∫ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è ‚Äî –ø–∞–∫–µ—Ç <code>testing</code>.</p>
<p>üìå <b>–ü—Ä–∞–≤–∏–ª–∞</b></p>
<ul>
    <li>–§–∞–π–ª—ã: <code>*_test.go</code></li>
    <li>–¢–µ—Å—Ç—ã: <code>func TestXxx(t *testing.T)</code></li>
    <li>
        –ü–∞–∫–µ—Ç:
        <ul>
            <li><code>package foo</code> ‚Äî white-box</li>
            <li><code>package foo_test</code> ‚Äî black-box (—á–∞—Å—Ç–æ —Ü–µ–Ω–∏—Ç—Å—è –≤—ã—à–µ, –ø–æ—Ç–æ–º—É —á—Ç–æ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –ø—É–±–ª–∏—á–Ω—ã–π API –ø–∞–∫–µ—Ç–∞.)</li>
        </ul>
    </li>
</ul>
<pre><code class="language-go">func TestSum(t *testing.T) {
    res := Sum(2, 3)
    if res != 5 {
        t.Fatalf("expected 5, got %d", res)
    }
}</code></pre>
<p>–ó–∞–ø—É—Å–∫ (–≤–µ—Å—å –ø—Ä–æ–µ–∫—Ç):</p>
<pre><code class="language-go">go test ./...</code></pre>
<p>–ó–∞–ø—É—Å–∫ (–∫–æ–Ω–∫—Ä–µ—Ç–Ω—É—é –ø–∞–ø–∫—É):</p>
<p>–§–ª–∞–≥ <code>-v</code> –≤—ã–≤–æ–¥–∏—Ç –ø–æ–¥—Ä–æ–±–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é</p>
<p>–§–ª–∞–≥ <code>-cover</code> –ø—Ä–æ—Ü–µ–Ω—Ç –ø–æ–∫—Ä—ã—Ç–∏—è –∫–æ–¥–∞ —Ç–µ—Å—Ç–∞–º–∏</p>
<pre><code class="language-go">go test ./cmd/folder...</code></pre>
<hr>
<h2>Table-driven tests</h2>
<p>–ö–∞–Ω–æ–Ω–∏—á–µ—Å–∫–∏–π –ø—Ä–∏–º–µ—Ä</p>
<pre><code class="language-go">func TestAbs(t *testing.T) {
    testTable := []struct {
        name string // –ù–∞–∑–≤–∞–Ω–∏–µ —Ç–µ—Å—Ç–∞
        in   int
        want int
    }{
        {"positive", 5, 5},
        {"negative", -5, 5},
        {"zero", 0, 0},
    }

    for _, tt := range testTable {
        t.Run(tt.name, func(t *testing.T) {
            if got := Abs(tt.in); got != tt.want {
                t.Errorf("Abs(%d) = %d, want %d", tt.in, got, tt.want)
            }
        })
    }
}</code></pre>
<p>‚ö†Ô∏è –í–∞–∂–Ω–æ:
    –î–æ Go 1.22 –±—ã–ª –±–∞–≥ —Å –∑–∞—Ö–≤–∞—Ç–æ–º <code>tt</code>, —Å–µ–π—á–∞—Å –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–æ, –Ω–æ <code>tt := tt</code> –≤—Å—ë –µ—â—ë –≤—Å—Ç—Ä–µ—á–∞–µ—Ç—Å—è –≤ –∫–æ–¥–µ.</p>

<hr>
<h2>Subtests (<code>r.Run</code>)</h2>
<p>–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è:</p>
<ul>
    <li>–ª–æ–≥–∏—á–µ—Å–∫–æ–π –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∏</li>
    <li>–ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã—Ö —Ç–µ—Å—Ç–æ–≤</li>
    <li>—á–∏—Ç–∞–µ–º—ã—Ö –æ—Ç—á—ë—Ç–æ–≤</li>
</ul>
<pre><code class="language-go">func TestService(t *testing.T) {
    t.Run("success", func(t *testing.T) {})
    t.Run("not_found", func(t *testing.T) {})
}</code></pre>

<hr>
<h2>–ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–µ —Ç–µ—Å—Ç—ã</h2>
<pre><code class="language-go">func TestParallel(t *testing.T) {
    t.Parallel()
    time.Sleep(time.Second)
}</code></pre>
<p>üìå –ù–µ–ª—å–∑—è <code>t.Parallel()</code>:</p>
<ul>
    <li>–ø—Ä–∏ shared state</li>
    <li>–ø—Ä–∏ —Ä–∞–±–æ—Ç–µ —Å env</li>
    <li>–ø—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ –æ–¥–Ω–æ–π –ë–î / –æ–¥–Ω–æ–≥–æ —Ñ–∞–π–ª–∞</li>
</ul>

<hr>
<h2>Setup / Teardown</h2>
<p>–í Go <b>–Ω–µ—Ç beforeEach/afterEach</b>, –≤—Å—ë –¥–µ–ª–∞–µ—Ç—Å—è —Ä—É–∫–∞–º–∏:</p>
<pre><code class="language-go">func TestMain(m *testing.M) {
    setup()
    code := m.Run()
    teardown()
    os.Exit(code)
}</code></pre>
<p>–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ä–µ–¥–∫–æ, –Ω–æ –æ—á–µ–Ω—å <b>–≤–∞–∂–Ω–æ –∑–Ω–∞—Ç—å</b>.</p>

<hr>
<h2>–ü—Ä–æ–≤–µ—Ä–∫–∏ –æ—à–∏–±–æ–∫ (–ø—Ä–∞–≤–∏–ª—å–Ω–æ!)</h2>
<p>‚ùå –ü–ª–æ—Ö–æ:</p>
<pre><code class="language-go">if err != nil {
    t.Fatal(err)
}</code></pre>
<p>‚úÖ –•–æ—Ä–æ—à–æ:</p>
<pre><code class="language-go">if err != nil {
    t.Fatal("expected error, got nil")
}</code></pre>
<p>–ò–ª–∏:</p>
<pre><code class="language-go">if !errors.Is(err, ErrNotFound) {
    t.Fatalf("expected ErrNotFound, got %v", err)
}</code></pre>

<hr>
<h2>Mock‚Äô–∏ –≤ Go</h2>
<p>–í Go –Ω–µ—Ç –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã—Ö <b>mock‚Äô–æ–≤</b>, –≤—Å—ë —á–µ—Ä–µ–∑ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã.</p>
<h3>–†—É—á–Ω–æ–π mock</h3>
<pre><code class="language-go">type mockRepo struct {
    data map[int]string
}

func (m *mockRepo) Get(id int) (string, error) {
    v, ok := m.data[id]
    if !ok {
        return "", ErrNotFound
    }
    return v, nil
}</code></pre>
<p>–†—É—á–Ω—ã–µ mock'–∏:</p>
<ul>
    <li>–ø—Ä–æ—â–µ</li>
    <li>–º–µ–Ω—å—à–µ –º–∞–≥–∏–∏</li>
    <li>—Ç–∏–ø–æ–±–µ–∑–æ–ø–∞—Å–Ω–æ</li>
    <li>—á–∏—Ç–∞–µ–º–æ</li>
</ul>

<hr>
<h2>–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ HTTP (Gin / net/http)</h2>
<pre><code class="language-go">req := httptest.NewRequest(http.MethodGet, "/ping", nil)
w := httptest.NewRecorder()

router.ServeHTTP(w, req)

if w.Code != http.StatusOK {
    t.Fatalf("expected 200, got %d", w.Code)
}</code></pre>

<hr>
<h2>–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ concurrency</h2>
<h3>–ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–µ–¥–ª–æ–∫–æ–≤</h3>
<pre><code class="language-go">done := make(chan struct{})
go func() {
    work()
    close(done)
}()

select {
case <-done:
case <-time.After(time.Second):
    t.Fatal("deadlock")
}</code></pre>
<code>-race</code>
<pre><code class="language-go">go test -race ./...</code></pre>

<hr>
<h2>Benchmark‚Äô–∏</h2>
<pre><code class="language-go">func BenchmarkSum(b *testing.B) {
    for i := 0; i < b.N; i++ {
        Sum(2, 3)
    }
}</code></pre>
<p>–ó–∞–ø—É—Å–∫:</p>
<pre><code class="language-go">go test -bench=. -benchmem</code></pre>
<blockquote class="note">–õ–æ–≥–∏ –≤ benchmark –ø–∏—Å–∞—Ç—å –Ω–µ–ª—å–∑—è. (–õ–æ–≥–∏ –ª–æ–º–∞—é—Ç –∏–∑–º–µ—Ä–µ–Ω–∏—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏.)</blockquote>

<hr>
<h2>Fuzz-—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ (Go ‚â• 1.18)</h2>
<pre><code class="language-go">func FuzzReverse(f *testing.F) {
    f.Add("hello")

    f.Fuzz(func(t *testing.T, s string) {
        r := Reverse(s)
        if Reverse(r) != s {
            t.Fatalf("broken")
        }
    })
}</code></pre>

<hr>
<h2>–ß—Ç–æ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ —Å–ø—Ä–æ—Å—è—Ç –Ω–∞ —Å–æ–±–µ—Å–µ</h2>
<p>–ß–µ–∫–ª–∏—Å—Ç:</p>
<ul>
    <li>‚úÖ table-driven tests</li>
    <li>‚úÖ t.Parallel</li>
    <li>‚úÖ TestMain</li>
    <li>‚úÖ mock —á–µ—Ä–µ–∑ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã</li>
    <li>‚úÖ go test -race</li>
    <li>‚úÖ black-box vs white-box</li>
</ul>


<hr>
<h2 id="unit-test">Unit-—Ç–µ—Å—Ç (–ø—Ä–∏–º–µ—Ä)</h2>
<p>–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –æ–¥–∏–Ω –∏–∑–æ–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —é–Ω–∏—Ç –ª–æ–≥–∏–∫–∏, –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –∑–∞–º–æ–∫–∞–Ω—ã, –ø—Ä–æ–≤–µ—Ä—è–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –±–∏–∑–Ω–µ—Å-–ª–æ–≥–∏–∫–∞ –º–µ—Ç–æ–¥–∞.</p>
<p>–í —Ç–µ—Å—Ç–µ:</p>
<ul>
    <li>‚ùå –Ω–µ—Ç —Ä–µ–∞–ª—å–Ω–æ–π –ë–î</li>
    <li>‚ùå –Ω–µ—Ç —Ä–µ–∞–ª—å–Ω–æ–≥–æ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è</li>
    <li>‚ùå –Ω–µ—Ç HTTP / gRPC</li>
    <li>‚ùå –Ω–µ—Ç Docker / Postgres</li>
    <li>‚úÖ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π –∑–∞–º–æ–∫–∞–Ω</li>
    <li>‚úÖ —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –ª–æ–≥–∏–∫–∞ —Å–µ—Ä–≤–∏—Å–∞</li>
</ul>
<hr>
<h3>–¢–µ—Å—Ç –±–∏–∑–Ω–µ—Å –ª–æ–≥–∏–∫–∏ —Å–µ—Ä–≤–∏—Å–∞</h3>
<h4>–ú–æ–∫–∏—Ä—É–µ–º —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π</h4>
<p>–î–æ–º–µ–Ω–Ω—ã–π —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π:</p>
<pre><code class="language-go">package domain

type UserRepository interface {
	CreateUser(user User) error
	DeleteUser(id uint) error
	GetByLogin(login string) (User, error)
	GetByID(id uint) (User, error)
	GetByIDs(ids []uint) ([]User, error)
	GetAll() ([]User, error)
}</code></pre>
<p>Mock —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è:</p>
<pre><code class="language-go">package mocks

import (
	"vago/internal/domain"

	"github.com/stretchr/testify/mock"
)

// UserRepo - –º–æ–∫ –¥–ª—è domain.UserRepository
type UserRepo struct {
	mock.Mock
}

func (m *UserRepo) CreateUser(user domain.User) error {
	args := m.Called(user)
	return args.Error(0)
}

func (m *UserRepo) DeleteUser(id uint) error {
	args := m.Called(id)
	return args.Error(0)
}

func (m *UserRepo) GetByLogin(login string) (domain.User, error) {
	args := m.Called(login)
	return args.Get(0).(domain.User), args.Error(1)
}

func (m *UserRepo) GetByID(id uint) (domain.User, error) {
	args := m.Called(id)
	return args.Get(0).(domain.User), args.Error(1)
}

func (m *UserRepo) GetByIDs(ids []uint) ([]domain.User, error) {
	args := m.Called(ids)
	return args.Get(0).([]domain.User), args.Error(1)
}

func (m *UserRepo) GetAll() ([]domain.User, error) {
	args := m.Called()
	return args.Get(0).([]domain.User), args.Error(1)
}</code></pre>
<p>Mock —Å–µ—Ä–≤–∏—Å–∞:</p>
<pre><code class="language-go">package user

import (
	"errors"
	"testing"
	"vago/internal/application/user/mocks"
	"vago/internal/domain"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"golang.org/x/crypto/bcrypt"
)

// Test_Service_CreateUser_Success –ø—Ä–æ–≤–µ—Ä—è–µ—Ç —É—Å–ø–µ—à–Ω–æ–µ —Å–æ–∑–¥–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
func Test_Service_CreateUser_Success(t *testing.T) {
	// Arrange (–ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞)
	repo := new(mocks.UserRepo)
	svc := NewService(repo, nil)

	dto := domain.DTO{
		Login:    "testuser",
		Password: "securePassword123",
		Email:    "test@example.com",
		Username: "Test User",
		Role:     domain.RoleUser,
		Color:    "#FF5733",
	}

	// –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –º–æ–∫: CreateUser –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤—ã–∑–≤–∞–Ω —Å –ª—é–±—ã–º User (–ø–∞—Ä–æ–ª—å –±—É–¥–µ—Ç –∑–∞—Ö–µ—à–∏—Ä–æ–≤–∞–Ω)
	repo.On("CreateUser", mock.MatchedBy(func(user domain.User) bool {
		// –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–∞—Ä–æ–ª—å –∑–∞—Ö–µ—à–∏—Ä–æ–≤–∞–Ω
		err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(dto.Password))
		return err == nil &&
			user.Login == dto.Login &&
			user.Email == dto.Email &&
			user.Username == dto.Username &&
			user.Role == dto.Role &&
			user.Color == dto.Color
	})).Return(nil)

	// Act (–¥–µ–π—Å—Ç–≤–∏–µ)
	err := svc.CreateUser(dto)

	// Assert (–ø—Ä–æ–≤–µ—Ä–∫–∞)
	assert.NoError(t, err)
	repo.AssertExpectations(t)
}

// Test_Service_CreateUser_RepositoryError –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∫—É –æ—à–∏–±–∫–∏ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è
func Test_Service_CreateUser_RepositoryError(t *testing.T) {
	// Arrange
	repo := new(mocks.UserRepo)
	svc := NewService(repo, nil)

	dto := domain.DTO{
		Login:    "testuser",
		Password: "password123",
		Email:    "test@example.com",
		Username: "Test User",
		Role:     domain.RoleUser,
		Color:    "#FF5733",
	}

	expectedErr := errors.New("–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º –ª–æ–≥–∏–Ω–æ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç")
	repo.On("CreateUser", mock.Anything).Return(expectedErr)

	// Act
	err := svc.CreateUser(dto)

	// Assert
	assert.Error(t, err)
	assert.Equal(t, expectedErr, err)
	repo.AssertExpectations(t)
}

// Test_Service_CreateUser_PasswordHashing –ø—Ä–æ–≤–µ—Ä—è–µ—Ç, —á—Ç–æ –ø–∞—Ä–æ–ª—å –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ —Ö–µ—à–∏—Ä—É–µ—Ç—Å—è
func Test_Service_CreateUser_PasswordHashing(t *testing.T) {
	// Arrange
	repo := new(mocks.UserRepo)
	svc := NewService(repo, nil)

	plainPassword := "mySecretPassword123"
	dto := domain.DTO{
		Login:    "testuser",
		Password: plainPassword,
		Email:    "test@example.com",
		Username: "Test User",
		Role:     domain.RoleUser,
		Color:    "#FF5733",
	}

	var capturedUser domain.User
	repo.On("CreateUser", mock.Anything).Run(func(args mock.Arguments) {
		capturedUser = args.Get(0).(domain.User)
	}).Return(nil)

	// Act
	err := svc.CreateUser(dto)

	// Assert
	assert.NoError(t, err)

	// –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–∞—Ä–æ–ª—å –ù–ï –æ—Å—Ç–∞–ª—Å—è –≤ –æ—Ç–∫—Ä—ã—Ç–æ–º –≤–∏–¥–µ
	assert.NotEqual(t, plainPassword, capturedUser.Password, "–ü–∞—Ä–æ–ª—å –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –∑–∞—Ö–µ—à–∏—Ä–æ–≤–∞–Ω")

	// –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ö–µ—à –º–æ–∂–Ω–æ –≤–µ—Ä–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞—Ç—å
	err = bcrypt.CompareHashAndPassword([]byte(capturedUser.Password), []byte(plainPassword))
	assert.NoError(t, err, "–•–µ—à –ø–∞—Ä–æ–ª—è –¥–æ–ª–∂–µ–Ω —Å–æ–≤–ø–∞–¥–∞—Ç—å —Å –∏—Å—Ö–æ–¥–Ω—ã–º –ø–∞—Ä–æ–ª–µ–º")

	repo.AssertExpectations(t)
}

// Test_Service_CreateUser_DifferentRoles —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç —Å–æ–∑–¥–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å —Ä–∞–∑–Ω—ã–º–∏ —Ä–æ–ª—è–º–∏
func Test_Service_CreateUser_DifferentRoles(t *testing.T) {
	tests := []struct {
		name string
		role domain.Role
	}{
		{"User role", domain.RoleUser},
		{"Moderator role", domain.RoleModerator},
		{"Admin role", domain.RoleAdmin},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Arrange
			repo := new(mocks.UserRepo)
			svc := NewService(repo, nil)

			dto := domain.DTO{
				Login:    "testuser",
				Password: "password123",
				Email:    "test@example.com",
				Username: "Test User",
				Role:     tt.role,
				Color:    "#FF5733",
			}

			var capturedUser domain.User
			repo.On("CreateUser", mock.Anything).Run(func(args mock.Arguments) {
				capturedUser = args.Get(0).(domain.User)
			}).Return(nil)

			// Act
			err := svc.CreateUser(dto)

			// Assert
			assert.NoError(t, err)
			assert.Equal(t, tt.role, capturedUser.Role)
			repo.AssertExpectations(t)
		})
	}
}
</code></pre>












{{ end }}